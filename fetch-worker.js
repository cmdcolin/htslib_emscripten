this.onerror = function(e) {
  console.error(e);
}


function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}
function getTotalMemory() {
  return TOTAL_MEMORY;
}
function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
function _emscripten_is_main_runtime_thread() {
    return __pthread_is_main_runtime_thread|0; // Semantically the same as testing "!ENVIRONMENT_IS_PTHREAD" outside the asm.js scope
}
function _emscripten_futex_wait(addr, val, timeout) {
      if (addr <= 0 || addr > HEAP8.length || addr&3 != 0) return -22;
  //    dump('futex_wait addr:' + addr + ' by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
      if (ENVIRONMENT_IS_WORKER) {
        var ret = Atomics.wait(HEAP32, addr >> 2, val, timeout);
  //    dump('futex_wait done by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
        if (ret === 'timed-out') return -110;
        if (ret === 'not-equal') return -11;
        if (ret === 'ok') return 0;
        throw 'Atomics.wait returned an unexpected value ' + ret;
      } else {
        // Atomics.wait is not available in the main browser thread, so simulate it via busy spinning.
        var loadedVal = Atomics.load(HEAP32, addr >> 2);
        if (val != loadedVal) return -11;
  
        var tNow = performance.now();
        var tEnd = tNow + timeout;
  
  
        // Register globally which address the main thread is simulating to be waiting on. When zero, main thread is not waiting on anything,
        // and on nonzero, the contents of address pointed by __main_thread_futex_wait_address tell which address the main thread is simulating its wait on.
        Atomics.store(HEAP32, __main_thread_futex_wait_address >> 2, addr);
        var ourWaitAddress = addr; // We may recursively re-enter this function while processing queued calls, in which case we'll do a spurious wakeup of the older wait operation.
        while (addr == ourWaitAddress) {
          tNow = performance.now();
          if (tNow > tEnd) {
            return -110;
          }
          _emscripten_main_thread_process_queued_calls(); // We are performing a blocking loop here, so must pump any pthreads if they want to perform operations that are proxied.
          addr = Atomics.load(HEAP32, __main_thread_futex_wait_address >> 2); // Look for a worker thread waking us up.
        }
        return 0;
      }
    }
function _malloc($0) {
 $0 = $0|0;
 var $$$0172$i = 0, $$$0173$i = 0, $$$4230$i = 0, $$$4236$i = 0, $$$4329$i = 0, $$$i = 0, $$0$i = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i17$i = 0, $$01$i$i = 0, $$0172$lcssa$i = 0, $$01726$i = 0, $$0173$lcssa$i = 0, $$01735$i = 0, $$0193 = 0, $$0195 = 0, $$0201$i$i = 0, $$0202$i$i = 0, $$0206$i$i = 0;
 var $$0207$i$i = 0, $$024362$i = 0, $$0260$i$i = 0, $$0261$i$i = 0, $$0262$i$i = 0, $$0268$i$i = 0, $$0269$i$i = 0, $$0320$i = 0, $$0322$i = 0, $$0323$i = 0, $$0325$i = 0, $$0331$i = 0, $$0336$i = 0, $$0337$$i = 0, $$0337$i = 0, $$0339$i = 0, $$0340$i = 0, $$0345$i = 0, $$1 = 0, $$1176$i = 0;
 var $$1178$i = 0, $$124461$i = 0, $$1264$i$i = 0, $$1266$i$i = 0, $$1321$i = 0, $$1326$i = 0, $$1341$i = 0, $$1347$i = 0, $$1351$i = 0, $$2 = 0, $$2234243136$i = 0, $$2247$ph$i = 0, $$2253$ph$i = 0, $$2333$i = 0, $$3$i = 0, $$3$i$i = 0, $$3$i196 = 0, $$3229$i = 0, $$3235$i = 0, $$3328$i = 0;
 var $$3349$i = 0, $$4$lcssa$i = 0, $$4$ph$i = 0, $$411$i = 0, $$4230$i = 0, $$4236$i = 0, $$4329$lcssa$i = 0, $$432910$i = 0, $$4335$$4$i = 0, $$4335$ph$i = 0, $$43359$i = 0, $$7$i = 0, $$7239$i = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i18$i = 0, $$pre$i205 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i19$iZ2D = 0;
 var $$pre$phi$i206Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $$sink1$i = 0, $$sink1$i$i = 0, $$sink14$i = 0, $$sink2$i = 0, $$sink2$i199 = 0, $$sink3$i = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0;
 var $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0;
 var $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0;
 var $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0;
 var $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0;
 var $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0;
 var $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0;
 var $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0;
 var $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0;
 var $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0;
 var $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0;
 var $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0;
 var $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0;
 var $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0;
 var $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0;
 var $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0;
 var $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0;
 var $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0;
 var $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0;
 var $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0;
 var $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0;
 var $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0;
 var $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0;
 var $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0;
 var $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0;
 var $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0;
 var $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0;
 var $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0;
 var $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0;
 var $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0;
 var $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0;
 var $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0;
 var $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0;
 var $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0;
 var $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0;
 var $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0;
 var $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0;
 var $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0;
 var $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0;
 var $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0;
 var $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0;
 var $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0;
 var $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0;
 var $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0;
 var $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0;
 var $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0;
 var $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0;
 var $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0;
 var $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0;
 var $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0;
 var $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0, $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $cond$i = 0, $cond$i$i = 0, $cond$i203 = 0, $exitcond$i$i = 0, $not$$i = 0, $not$$i$i = 0, $not$$i204 = 0, $not$1$i = 0, $not$1$i198 = 0;
 var $not$3$i = 0, $not$5$i = 0, $or$cond$i = 0, $or$cond$i207 = 0, $or$cond1$i = 0, $or$cond10$i = 0, $or$cond11$i = 0, $or$cond12$i = 0, $or$cond2$i = 0, $or$cond2$i208 = 0, $or$cond42$i = 0, $or$cond5$i = 0, $or$cond7$i = 0, $or$cond9$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abortStackOverflow(16|0);
 $1 = sp + 12|0;
 $2 = sp + 8|0;
 $3 = sp + 4|0;
 $4 = sp;
 $5 = HEAP32[893]|0;
 $6 = ($5|0)==(0);
 if ($6) {
  (___pthread_mutex_lock(3596)|0);
  $7 = HEAP32[893]|0;
  $8 = ($7|0)==(0);
  if ($8) {
   HEAP32[(3580)>>2] = 4096;
   HEAP32[(3576)>>2] = 4096;
   HEAP32[(3584)>>2] = -1;
   HEAP32[(3588)>>2] = -1;
   HEAP32[(3592)>>2] = 2;
   HEAP32[(4068)>>2] = 2;
   $9 = (_pthread_mutexattr_init($3)|0);
   $10 = ($9|0)==(0);
   if ($10) {
    $11 = (_pthread_mutex_init((4072),$3)|0);
    $12 = ($11|0)==(0);
    if ($12) {
     (_pthread_mutexattr_destroy($3)|0);
    }
   }
   $13 = $4;
   $14 = $13 & -16;
   $15 = $14 ^ 1431655768;
   HEAP32[$4>>2] = $15;
   Atomics_store(HEAP32,893,$15)|0;
  }
  (___pthread_mutex_unlock(3596)|0);
 }
 $16 = HEAP32[(4068)>>2]|0;
 $17 = $16 & 2;
 $18 = ($17|0)==(0);
 if (!($18)) {
  $19 = (___pthread_mutex_lock((4072))|0);
  $20 = ($19|0)==(0);
  if (!($20)) {
   $$1 = 0;
   STACKTOP = sp;return ($$1|0);
  }
 }
 $21 = ($0>>>0)<(245);
 do {
  if ($21) {
   $22 = ($0>>>0)<(11);
   $23 = (($0) + 11)|0;
   $24 = $23 & -8;
   $25 = $22 ? 16 : $24;
   $26 = $25 >>> 3;
   $27 = HEAP32[906]|0;
   $28 = $27 >>> $26;
   $29 = $28 & 3;
   $30 = ($29|0)==(0);
   if (!($30)) {
    $31 = $28 & 1;
    $32 = $31 ^ 1;
    $33 = (($32) + ($26))|0;
    $34 = $33 << 1;
    $35 = (3664 + ($34<<2)|0);
    $36 = ((($35)) + 8|0);
    $37 = HEAP32[$36>>2]|0;
    $38 = ((($37)) + 8|0);
    $39 = HEAP32[$38>>2]|0;
    $40 = ($35|0)==($39|0);
    if ($40) {
     $41 = 1 << $33;
     $42 = $41 ^ -1;
     $43 = $27 & $42;
     HEAP32[906] = $43;
    } else {
     $44 = ((($39)) + 12|0);
     HEAP32[$44>>2] = $35;
     HEAP32[$36>>2] = $39;
    }
    $45 = $33 << 3;
    $46 = $45 | 3;
    $47 = ((($37)) + 4|0);
    HEAP32[$47>>2] = $46;
    $48 = (($37) + ($45)|0);
    $49 = ((($48)) + 4|0);
    $50 = HEAP32[$49>>2]|0;
    $51 = $50 | 1;
    HEAP32[$49>>2] = $51;
    $$2 = $38;
    break;
   }
   $52 = HEAP32[(3632)>>2]|0;
   $53 = ($25>>>0)>($52>>>0);
   if ($53) {
    $54 = ($28|0)==(0);
    if (!($54)) {
     $55 = $28 << $26;
     $56 = 2 << $26;
     $57 = (0 - ($56))|0;
     $58 = $56 | $57;
     $59 = $55 & $58;
     $60 = (0 - ($59))|0;
     $61 = $59 & $60;
     $62 = (($61) + -1)|0;
     $63 = $62 >>> 12;
     $64 = $63 & 16;
     $65 = $62 >>> $64;
     $66 = $65 >>> 5;
     $67 = $66 & 8;
     $68 = $67 | $64;
     $69 = $65 >>> $67;
     $70 = $69 >>> 2;
     $71 = $70 & 4;
     $72 = $68 | $71;
     $73 = $69 >>> $71;
     $74 = $73 >>> 1;
     $75 = $74 & 2;
     $76 = $72 | $75;
     $77 = $73 >>> $75;
     $78 = $77 >>> 1;
     $79 = $78 & 1;
     $80 = $76 | $79;
     $81 = $77 >>> $79;
     $82 = (($80) + ($81))|0;
     $83 = $82 << 1;
     $84 = (3664 + ($83<<2)|0);
     $85 = ((($84)) + 8|0);
     $86 = HEAP32[$85>>2]|0;
     $87 = ((($86)) + 8|0);
     $88 = HEAP32[$87>>2]|0;
     $89 = ($84|0)==($88|0);
     if ($89) {
      $90 = 1 << $82;
      $91 = $90 ^ -1;
      $92 = $27 & $91;
      HEAP32[906] = $92;
      $109 = $92;
     } else {
      $93 = ((($88)) + 12|0);
      HEAP32[$93>>2] = $84;
      HEAP32[$85>>2] = $88;
      $109 = $27;
     }
     $94 = $82 << 3;
     $95 = (($94) - ($25))|0;
     $96 = $25 | 3;
     $97 = ((($86)) + 4|0);
     HEAP32[$97>>2] = $96;
     $98 = (($86) + ($25)|0);
     $99 = $95 | 1;
     $100 = ((($98)) + 4|0);
     HEAP32[$100>>2] = $99;
     $101 = (($98) + ($95)|0);
     HEAP32[$101>>2] = $95;
     $102 = ($52|0)==(0);
     if (!($102)) {
      $103 = HEAP32[(3644)>>2]|0;
      $104 = $52 >>> 3;
      $105 = $104 << 1;
      $106 = (3664 + ($105<<2)|0);
      $107 = 1 << $104;
      $108 = $109 & $107;
      $110 = ($108|0)==(0);
      if ($110) {
       $111 = $109 | $107;
       HEAP32[906] = $111;
       $$pre = ((($106)) + 8|0);
       $$0195 = $106;$$pre$phiZ2D = $$pre;
      } else {
       $112 = ((($106)) + 8|0);
       $113 = HEAP32[$112>>2]|0;
       $$0195 = $113;$$pre$phiZ2D = $112;
      }
      HEAP32[$$pre$phiZ2D>>2] = $103;
      $114 = ((($$0195)) + 12|0);
      HEAP32[$114>>2] = $103;
      $115 = ((($103)) + 8|0);
      HEAP32[$115>>2] = $$0195;
      $116 = ((($103)) + 12|0);
      HEAP32[$116>>2] = $106;
     }
     HEAP32[(3632)>>2] = $95;
     HEAP32[(3644)>>2] = $98;
     $$2 = $87;
     break;
    }
    $117 = HEAP32[(3628)>>2]|0;
    $118 = ($117|0)==(0);
    if ($118) {
     $$0193 = $25;
     label = 108;
    } else {
     $119 = (0 - ($117))|0;
     $120 = $117 & $119;
     $121 = (($120) + -1)|0;
     $122 = $121 >>> 12;
     $123 = $122 & 16;
     $124 = $121 >>> $123;
     $125 = $124 >>> 5;
     $126 = $125 & 8;
     $127 = $126 | $123;
     $128 = $124 >>> $126;
     $129 = $128 >>> 2;
     $130 = $129 & 4;
     $131 = $127 | $130;
     $132 = $128 >>> $130;
     $133 = $132 >>> 1;
     $134 = $133 & 2;
     $135 = $131 | $134;
     $136 = $132 >>> $134;
     $137 = $136 >>> 1;
     $138 = $137 & 1;
     $139 = $135 | $138;
     $140 = $136 >>> $138;
     $141 = (($139) + ($140))|0;
     $142 = (3928 + ($141<<2)|0);
     $143 = HEAP32[$142>>2]|0;
     $144 = ((($143)) + 4|0);
     $145 = HEAP32[$144>>2]|0;
     $146 = $145 & -8;
     $147 = (($146) - ($25))|0;
     $148 = ((($143)) + 16|0);
     $149 = HEAP32[$148>>2]|0;
     $not$3$i = ($149|0)==(0|0);
     $$sink14$i = $not$3$i&1;
     $150 = (((($143)) + 16|0) + ($$sink14$i<<2)|0);
     $151 = HEAP32[$150>>2]|0;
     $152 = ($151|0)==(0|0);
     if ($152) {
      $$0172$lcssa$i = $143;$$0173$lcssa$i = $147;
     } else {
      $$01726$i = $143;$$01735$i = $147;$154 = $151;
      while(1) {
       $153 = ((($154)) + 4|0);
       $155 = HEAP32[$153>>2]|0;
       $156 = $155 & -8;
       $157 = (($156) - ($25))|0;
       $158 = ($157>>>0)<($$01735$i>>>0);
       $$$0173$i = $158 ? $157 : $$01735$i;
       $$$0172$i = $158 ? $154 : $$01726$i;
       $159 = ((($154)) + 16|0);
       $160 = HEAP32[$159>>2]|0;
       $not$$i = ($160|0)==(0|0);
       $$sink1$i = $not$$i&1;
       $161 = (((($154)) + 16|0) + ($$sink1$i<<2)|0);
       $162 = HEAP32[$161>>2]|0;
       $163 = ($162|0)==(0|0);
       if ($163) {
        $$0172$lcssa$i = $$$0172$i;$$0173$lcssa$i = $$$0173$i;
        break;
       } else {
        $$01726$i = $$$0172$i;$$01735$i = $$$0173$i;$154 = $162;
       }
      }
     }
     $164 = (($$0172$lcssa$i) + ($25)|0);
     $165 = ($$0172$lcssa$i>>>0)<($164>>>0);
     if ($165) {
      $166 = ((($$0172$lcssa$i)) + 24|0);
      $167 = HEAP32[$166>>2]|0;
      $168 = ((($$0172$lcssa$i)) + 12|0);
      $169 = HEAP32[$168>>2]|0;
      $170 = ($169|0)==($$0172$lcssa$i|0);
      do {
       if ($170) {
        $175 = ((($$0172$lcssa$i)) + 20|0);
        $176 = HEAP32[$175>>2]|0;
        $177 = ($176|0)==(0|0);
        if ($177) {
         $178 = ((($$0172$lcssa$i)) + 16|0);
         $179 = HEAP32[$178>>2]|0;
         $180 = ($179|0)==(0|0);
         if ($180) {
          $$3$i = 0;
          break;
         } else {
          $$1176$i = $179;$$1178$i = $178;
         }
        } else {
         $$1176$i = $176;$$1178$i = $175;
        }
        while(1) {
         $181 = ((($$1176$i)) + 20|0);
         $182 = HEAP32[$181>>2]|0;
         $183 = ($182|0)==(0|0);
         if (!($183)) {
          $$1176$i = $182;$$1178$i = $181;
          continue;
         }
         $184 = ((($$1176$i)) + 16|0);
         $185 = HEAP32[$184>>2]|0;
         $186 = ($185|0)==(0|0);
         if ($186) {
          break;
         } else {
          $$1176$i = $185;$$1178$i = $184;
         }
        }
        HEAP32[$$1178$i>>2] = 0;
        $$3$i = $$1176$i;
       } else {
        $171 = ((($$0172$lcssa$i)) + 8|0);
        $172 = HEAP32[$171>>2]|0;
        $173 = ((($172)) + 12|0);
        HEAP32[$173>>2] = $169;
        $174 = ((($169)) + 8|0);
        HEAP32[$174>>2] = $172;
        $$3$i = $169;
       }
      } while(0);
      $187 = ($167|0)==(0|0);
      do {
       if (!($187)) {
        $188 = ((($$0172$lcssa$i)) + 28|0);
        $189 = HEAP32[$188>>2]|0;
        $190 = (3928 + ($189<<2)|0);
        $191 = HEAP32[$190>>2]|0;
        $192 = ($$0172$lcssa$i|0)==($191|0);
        if ($192) {
         HEAP32[$190>>2] = $$3$i;
         $cond$i = ($$3$i|0)==(0|0);
         if ($cond$i) {
          $193 = 1 << $189;
          $194 = $193 ^ -1;
          $195 = $117 & $194;
          HEAP32[(3628)>>2] = $195;
          break;
         }
        } else {
         $196 = ((($167)) + 16|0);
         $197 = HEAP32[$196>>2]|0;
         $not$1$i = ($197|0)!=($$0172$lcssa$i|0);
         $$sink2$i = $not$1$i&1;
         $198 = (((($167)) + 16|0) + ($$sink2$i<<2)|0);
         HEAP32[$198>>2] = $$3$i;
         $199 = ($$3$i|0)==(0|0);
         if ($199) {
          break;
         }
        }
        $200 = ((($$3$i)) + 24|0);
        HEAP32[$200>>2] = $167;
        $201 = ((($$0172$lcssa$i)) + 16|0);
        $202 = HEAP32[$201>>2]|0;
        $203 = ($202|0)==(0|0);
        if (!($203)) {
         $204 = ((($$3$i)) + 16|0);
         HEAP32[$204>>2] = $202;
         $205 = ((($202)) + 24|0);
         HEAP32[$205>>2] = $$3$i;
        }
        $206 = ((($$0172$lcssa$i)) + 20|0);
        $207 = HEAP32[$206>>2]|0;
        $208 = ($207|0)==(0|0);
        if (!($208)) {
         $209 = ((($$3$i)) + 20|0);
         HEAP32[$209>>2] = $207;
         $210 = ((($207)) + 24|0);
         HEAP32[$210>>2] = $$3$i;
        }
       }
      } while(0);
      $211 = ($$0173$lcssa$i>>>0)<(16);
      if ($211) {
       $212 = (($$0173$lcssa$i) + ($25))|0;
       $213 = $212 | 3;
       $214 = ((($$0172$lcssa$i)) + 4|0);
       HEAP32[$214>>2] = $213;
       $215 = (($$0172$lcssa$i) + ($212)|0);
       $216 = ((($215)) + 4|0);
       $217 = HEAP32[$216>>2]|0;
       $218 = $217 | 1;
       HEAP32[$216>>2] = $218;
      } else {
       $219 = $25 | 3;
       $220 = ((($$0172$lcssa$i)) + 4|0);
       HEAP32[$220>>2] = $219;
       $221 = $$0173$lcssa$i | 1;
       $222 = ((($164)) + 4|0);
       HEAP32[$222>>2] = $221;
       $223 = (($164) + ($$0173$lcssa$i)|0);
       HEAP32[$223>>2] = $$0173$lcssa$i;
       $224 = ($52|0)==(0);
       if (!($224)) {
        $225 = HEAP32[(3644)>>2]|0;
        $226 = $52 >>> 3;
        $227 = $226 << 1;
        $228 = (3664 + ($227<<2)|0);
        $229 = 1 << $226;
        $230 = $27 & $229;
        $231 = ($230|0)==(0);
        if ($231) {
         $232 = $27 | $229;
         HEAP32[906] = $232;
         $$pre$i = ((($228)) + 8|0);
         $$0$i = $228;$$pre$phi$iZ2D = $$pre$i;
        } else {
         $233 = ((($228)) + 8|0);
         $234 = HEAP32[$233>>2]|0;
         $$0$i = $234;$$pre$phi$iZ2D = $233;
        }
        HEAP32[$$pre$phi$iZ2D>>2] = $225;
        $235 = ((($$0$i)) + 12|0);
        HEAP32[$235>>2] = $225;
        $236 = ((($225)) + 8|0);
        HEAP32[$236>>2] = $$0$i;
        $237 = ((($225)) + 12|0);
        HEAP32[$237>>2] = $228;
       }
       HEAP32[(3632)>>2] = $$0173$lcssa$i;
       HEAP32[(3644)>>2] = $164;
      }
      $238 = ((($$0172$lcssa$i)) + 8|0);
      $$2 = $238;
     } else {
      $$0193 = $25;
      label = 108;
     }
    }
   } else {
    $$0193 = $25;
    label = 108;
   }
  } else {
   $239 = ($0>>>0)>(4294967231);
   if ($239) {
    $$0193 = -1;
    label = 108;
   } else {
    $240 = (($0) + 11)|0;
    $241 = $240 & -8;
    $242 = HEAP32[(3628)>>2]|0;
    $243 = ($242|0)==(0);
    if ($243) {
     $$0193 = $241;
     label = 108;
    } else {
     $244 = (0 - ($241))|0;
     $245 = $240 >>> 8;
     $246 = ($245|0)==(0);
     if ($246) {
      $$0336$i = 0;
     } else {
      $247 = ($241>>>0)>(16777215);
      if ($247) {
       $$0336$i = 31;
      } else {
       $248 = (($245) + 1048320)|0;
       $249 = $248 >>> 16;
       $250 = $249 & 8;
       $251 = $245 << $250;
       $252 = (($251) + 520192)|0;
       $253 = $252 >>> 16;
       $254 = $253 & 4;
       $255 = $254 | $250;
       $256 = $251 << $254;
       $257 = (($256) + 245760)|0;
       $258 = $257 >>> 16;
       $259 = $258 & 2;
       $260 = $255 | $259;
       $261 = (14 - ($260))|0;
       $262 = $256 << $259;
       $263 = $262 >>> 15;
       $264 = (($261) + ($263))|0;
       $265 = $264 << 1;
       $266 = (($264) + 7)|0;
       $267 = $241 >>> $266;
       $268 = $267 & 1;
       $269 = $268 | $265;
       $$0336$i = $269;
      }
     }
     $270 = (3928 + ($$0336$i<<2)|0);
     $271 = HEAP32[$270>>2]|0;
     $272 = ($271|0)==(0|0);
     L85: do {
      if ($272) {
       $$2333$i = 0;$$3$i196 = 0;$$3328$i = $244;
       label = 66;
      } else {
       $273 = ($$0336$i|0)==(31);
       $274 = $$0336$i >>> 1;
       $275 = (25 - ($274))|0;
       $276 = $273 ? 0 : $275;
       $277 = $241 << $276;
       $$0320$i = 0;$$0325$i = $244;$$0331$i = $271;$$0337$i = $277;$$0340$i = 0;
       while(1) {
        $278 = ((($$0331$i)) + 4|0);
        $279 = HEAP32[$278>>2]|0;
        $280 = $279 & -8;
        $281 = (($280) - ($241))|0;
        $282 = ($281>>>0)<($$0325$i>>>0);
        if ($282) {
         $283 = ($281|0)==(0);
         if ($283) {
          $$411$i = $$0331$i;$$432910$i = 0;$$43359$i = $$0331$i;
          label = 70;
          break L85;
         } else {
          $$1321$i = $$0331$i;$$1326$i = $281;
         }
        } else {
         $$1321$i = $$0320$i;$$1326$i = $$0325$i;
        }
        $284 = ((($$0331$i)) + 20|0);
        $285 = HEAP32[$284>>2]|0;
        $286 = $$0337$i >>> 31;
        $287 = (((($$0331$i)) + 16|0) + ($286<<2)|0);
        $288 = HEAP32[$287>>2]|0;
        $289 = ($285|0)==(0|0);
        $290 = ($285|0)==($288|0);
        $or$cond2$i = $289 | $290;
        $$1341$i = $or$cond2$i ? $$0340$i : $285;
        $291 = ($288|0)==(0|0);
        $not$5$i = $291 ^ 1;
        $292 = $not$5$i&1;
        $$0337$$i = $$0337$i << $292;
        if ($291) {
         $$2333$i = $$1341$i;$$3$i196 = $$1321$i;$$3328$i = $$1326$i;
         label = 66;
         break;
        } else {
         $$0320$i = $$1321$i;$$0325$i = $$1326$i;$$0331$i = $288;$$0337$i = $$0337$$i;$$0340$i = $$1341$i;
        }
       }
      }
     } while(0);
     if ((label|0) == 66) {
      $293 = ($$2333$i|0)==(0|0);
      $294 = ($$3$i196|0)==(0|0);
      $or$cond$i = $293 & $294;
      if ($or$cond$i) {
       $295 = 2 << $$0336$i;
       $296 = (0 - ($295))|0;
       $297 = $295 | $296;
       $298 = $242 & $297;
       $299 = ($298|0)==(0);
       if ($299) {
        $$0193 = $241;
        label = 108;
        break;
       }
       $300 = (0 - ($298))|0;
       $301 = $298 & $300;
       $302 = (($301) + -1)|0;
       $303 = $302 >>> 12;
       $304 = $303 & 16;
       $305 = $302 >>> $304;
       $306 = $305 >>> 5;
       $307 = $306 & 8;
       $308 = $307 | $304;
       $309 = $305 >>> $307;
       $310 = $309 >>> 2;
       $311 = $310 & 4;
       $312 = $308 | $311;
       $313 = $309 >>> $311;
       $314 = $313 >>> 1;
       $315 = $314 & 2;
       $316 = $312 | $315;
       $317 = $313 >>> $315;
       $318 = $317 >>> 1;
       $319 = $318 & 1;
       $320 = $316 | $319;
       $321 = $317 >>> $319;
       $322 = (($320) + ($321))|0;
       $323 = (3928 + ($322<<2)|0);
       $324 = HEAP32[$323>>2]|0;
       $$4$ph$i = 0;$$4335$ph$i = $324;
      } else {
       $$4$ph$i = $$3$i196;$$4335$ph$i = $$2333$i;
      }
      $325 = ($$4335$ph$i|0)==(0|0);
      if ($325) {
       $$4$lcssa$i = $$4$ph$i;$$4329$lcssa$i = $$3328$i;
      } else {
       $$411$i = $$4$ph$i;$$432910$i = $$3328$i;$$43359$i = $$4335$ph$i;
       label = 70;
      }
     }
     if ((label|0) == 70) {
      while(1) {
       label = 0;
       $326 = ((($$43359$i)) + 4|0);
       $327 = HEAP32[$326>>2]|0;
       $328 = $327 & -8;
       $329 = (($328) - ($241))|0;
       $330 = ($329>>>0)<($$432910$i>>>0);
       $$$4329$i = $330 ? $329 : $$432910$i;
       $$4335$$4$i = $330 ? $$43359$i : $$411$i;
       $331 = ((($$43359$i)) + 16|0);
       $332 = HEAP32[$331>>2]|0;
       $not$1$i198 = ($332|0)==(0|0);
       $$sink2$i199 = $not$1$i198&1;
       $333 = (((($$43359$i)) + 16|0) + ($$sink2$i199<<2)|0);
       $334 = HEAP32[$333>>2]|0;
       $335 = ($334|0)==(0|0);
       if ($335) {
        $$4$lcssa$i = $$4335$$4$i;$$4329$lcssa$i = $$$4329$i;
        break;
       } else {
        $$411$i = $$4335$$4$i;$$432910$i = $$$4329$i;$$43359$i = $334;
        label = 70;
       }
      }
     }
     $336 = ($$4$lcssa$i|0)==(0|0);
     if ($336) {
      $$0193 = $241;
      label = 108;
     } else {
      $337 = HEAP32[(3632)>>2]|0;
      $338 = (($337) - ($241))|0;
      $339 = ($$4329$lcssa$i>>>0)<($338>>>0);
      if ($339) {
       $340 = (($$4$lcssa$i) + ($241)|0);
       $341 = ($$4$lcssa$i>>>0)<($340>>>0);
       if ($341) {
        $342 = ((($$4$lcssa$i)) + 24|0);
        $343 = HEAP32[$342>>2]|0;
        $344 = ((($$4$lcssa$i)) + 12|0);
        $345 = HEAP32[$344>>2]|0;
        $346 = ($345|0)==($$4$lcssa$i|0);
        do {
         if ($346) {
          $351 = ((($$4$lcssa$i)) + 20|0);
          $352 = HEAP32[$351>>2]|0;
          $353 = ($352|0)==(0|0);
          if ($353) {
           $354 = ((($$4$lcssa$i)) + 16|0);
           $355 = HEAP32[$354>>2]|0;
           $356 = ($355|0)==(0|0);
           if ($356) {
            $$3349$i = 0;
            break;
           } else {
            $$1347$i = $355;$$1351$i = $354;
           }
          } else {
           $$1347$i = $352;$$1351$i = $351;
          }
          while(1) {
           $357 = ((($$1347$i)) + 20|0);
           $358 = HEAP32[$357>>2]|0;
           $359 = ($358|0)==(0|0);
           if (!($359)) {
            $$1347$i = $358;$$1351$i = $357;
            continue;
           }
           $360 = ((($$1347$i)) + 16|0);
           $361 = HEAP32[$360>>2]|0;
           $362 = ($361|0)==(0|0);
           if ($362) {
            break;
           } else {
            $$1347$i = $361;$$1351$i = $360;
           }
          }
          HEAP32[$$1351$i>>2] = 0;
          $$3349$i = $$1347$i;
         } else {
          $347 = ((($$4$lcssa$i)) + 8|0);
          $348 = HEAP32[$347>>2]|0;
          $349 = ((($348)) + 12|0);
          HEAP32[$349>>2] = $345;
          $350 = ((($345)) + 8|0);
          HEAP32[$350>>2] = $348;
          $$3349$i = $345;
         }
        } while(0);
        $363 = ($343|0)==(0|0);
        do {
         if ($363) {
          $445 = $242;
         } else {
          $364 = ((($$4$lcssa$i)) + 28|0);
          $365 = HEAP32[$364>>2]|0;
          $366 = (3928 + ($365<<2)|0);
          $367 = HEAP32[$366>>2]|0;
          $368 = ($$4$lcssa$i|0)==($367|0);
          if ($368) {
           HEAP32[$366>>2] = $$3349$i;
           $cond$i203 = ($$3349$i|0)==(0|0);
           if ($cond$i203) {
            $369 = 1 << $365;
            $370 = $369 ^ -1;
            $371 = $242 & $370;
            HEAP32[(3628)>>2] = $371;
            $445 = $371;
            break;
           }
          } else {
           $372 = ((($343)) + 16|0);
           $373 = HEAP32[$372>>2]|0;
           $not$$i204 = ($373|0)!=($$4$lcssa$i|0);
           $$sink3$i = $not$$i204&1;
           $374 = (((($343)) + 16|0) + ($$sink3$i<<2)|0);
           HEAP32[$374>>2] = $$3349$i;
           $375 = ($$3349$i|0)==(0|0);
           if ($375) {
            $445 = $242;
            break;
           }
          }
          $376 = ((($$3349$i)) + 24|0);
          HEAP32[$376>>2] = $343;
          $377 = ((($$4$lcssa$i)) + 16|0);
          $378 = HEAP32[$377>>2]|0;
          $379 = ($378|0)==(0|0);
          if (!($379)) {
           $380 = ((($$3349$i)) + 16|0);
           HEAP32[$380>>2] = $378;
           $381 = ((($378)) + 24|0);
           HEAP32[$381>>2] = $$3349$i;
          }
          $382 = ((($$4$lcssa$i)) + 20|0);
          $383 = HEAP32[$382>>2]|0;
          $384 = ($383|0)==(0|0);
          if ($384) {
           $445 = $242;
          } else {
           $385 = ((($$3349$i)) + 20|0);
           HEAP32[$385>>2] = $383;
           $386 = ((($383)) + 24|0);
           HEAP32[$386>>2] = $$3349$i;
           $445 = $242;
          }
         }
        } while(0);
        $387 = ($$4329$lcssa$i>>>0)<(16);
        do {
         if ($387) {
          $388 = (($$4329$lcssa$i) + ($241))|0;
          $389 = $388 | 3;
          $390 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$390>>2] = $389;
          $391 = (($$4$lcssa$i) + ($388)|0);
          $392 = ((($391)) + 4|0);
          $393 = HEAP32[$392>>2]|0;
          $394 = $393 | 1;
          HEAP32[$392>>2] = $394;
         } else {
          $395 = $241 | 3;
          $396 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$396>>2] = $395;
          $397 = $$4329$lcssa$i | 1;
          $398 = ((($340)) + 4|0);
          HEAP32[$398>>2] = $397;
          $399 = (($340) + ($$4329$lcssa$i)|0);
          HEAP32[$399>>2] = $$4329$lcssa$i;
          $400 = $$4329$lcssa$i >>> 3;
          $401 = ($$4329$lcssa$i>>>0)<(256);
          if ($401) {
           $402 = $400 << 1;
           $403 = (3664 + ($402<<2)|0);
           $404 = HEAP32[906]|0;
           $405 = 1 << $400;
           $406 = $404 & $405;
           $407 = ($406|0)==(0);
           if ($407) {
            $408 = $404 | $405;
            HEAP32[906] = $408;
            $$pre$i205 = ((($403)) + 8|0);
            $$0345$i = $403;$$pre$phi$i206Z2D = $$pre$i205;
           } else {
            $409 = ((($403)) + 8|0);
            $410 = HEAP32[$409>>2]|0;
            $$0345$i = $410;$$pre$phi$i206Z2D = $409;
           }
           HEAP32[$$pre$phi$i206Z2D>>2] = $340;
           $411 = ((($$0345$i)) + 12|0);
           HEAP32[$411>>2] = $340;
           $412 = ((($340)) + 8|0);
           HEAP32[$412>>2] = $$0345$i;
           $413 = ((($340)) + 12|0);
           HEAP32[$413>>2] = $403;
           break;
          }
          $414 = $$4329$lcssa$i >>> 8;
          $415 = ($414|0)==(0);
          if ($415) {
           $$0339$i = 0;
          } else {
           $416 = ($$4329$lcssa$i>>>0)>(16777215);
           if ($416) {
            $$0339$i = 31;
           } else {
            $417 = (($414) + 1048320)|0;
            $418 = $417 >>> 16;
            $419 = $418 & 8;
            $420 = $414 << $419;
            $421 = (($420) + 520192)|0;
            $422 = $421 >>> 16;
            $423 = $422 & 4;
            $424 = $423 | $419;
            $425 = $420 << $423;
            $426 = (($425) + 245760)|0;
            $427 = $426 >>> 16;
            $428 = $427 & 2;
            $429 = $424 | $428;
            $430 = (14 - ($429))|0;
            $431 = $425 << $428;
            $432 = $431 >>> 15;
            $433 = (($430) + ($432))|0;
            $434 = $433 << 1;
            $435 = (($433) + 7)|0;
            $436 = $$4329$lcssa$i >>> $435;
            $437 = $436 & 1;
            $438 = $437 | $434;
            $$0339$i = $438;
           }
          }
          $439 = (3928 + ($$0339$i<<2)|0);
          $440 = ((($340)) + 28|0);
          HEAP32[$440>>2] = $$0339$i;
          $441 = ((($340)) + 16|0);
          $442 = ((($441)) + 4|0);
          HEAP32[$442>>2] = 0;
          HEAP32[$441>>2] = 0;
          $443 = 1 << $$0339$i;
          $444 = $445 & $443;
          $446 = ($444|0)==(0);
          if ($446) {
           $447 = $445 | $443;
           HEAP32[(3628)>>2] = $447;
           HEAP32[$439>>2] = $340;
           $448 = ((($340)) + 24|0);
           HEAP32[$448>>2] = $439;
           $449 = ((($340)) + 12|0);
           HEAP32[$449>>2] = $340;
           $450 = ((($340)) + 8|0);
           HEAP32[$450>>2] = $340;
           break;
          }
          $451 = HEAP32[$439>>2]|0;
          $452 = ($$0339$i|0)==(31);
          $453 = $$0339$i >>> 1;
          $454 = (25 - ($453))|0;
          $455 = $452 ? 0 : $454;
          $456 = $$4329$lcssa$i << $455;
          $$0322$i = $456;$$0323$i = $451;
          while(1) {
           $457 = ((($$0323$i)) + 4|0);
           $458 = HEAP32[$457>>2]|0;
           $459 = $458 & -8;
           $460 = ($459|0)==($$4329$lcssa$i|0);
           if ($460) {
            label = 106;
            break;
           }
           $461 = $$0322$i >>> 31;
           $462 = (((($$0323$i)) + 16|0) + ($461<<2)|0);
           $463 = $$0322$i << 1;
           $464 = HEAP32[$462>>2]|0;
           $465 = ($464|0)==(0|0);
           if ($465) {
            label = 105;
            break;
           } else {
            $$0322$i = $463;$$0323$i = $464;
           }
          }
          if ((label|0) == 105) {
           HEAP32[$462>>2] = $340;
           $466 = ((($340)) + 24|0);
           HEAP32[$466>>2] = $$0323$i;
           $467 = ((($340)) + 12|0);
           HEAP32[$467>>2] = $340;
           $468 = ((($340)) + 8|0);
           HEAP32[$468>>2] = $340;
           break;
          }
          else if ((label|0) == 106) {
           $469 = ((($$0323$i)) + 8|0);
           $470 = HEAP32[$469>>2]|0;
           $471 = ((($470)) + 12|0);
           HEAP32[$471>>2] = $340;
           HEAP32[$469>>2] = $340;
           $472 = ((($340)) + 8|0);
           HEAP32[$472>>2] = $470;
           $473 = ((($340)) + 12|0);
           HEAP32[$473>>2] = $$0323$i;
           $474 = ((($340)) + 24|0);
           HEAP32[$474>>2] = 0;
           break;
          }
         }
        } while(0);
        $475 = ((($$4$lcssa$i)) + 8|0);
        $$2 = $475;
       } else {
        $$2 = 0;
       }
      } else {
       $$0193 = $241;
       label = 108;
      }
     }
    }
   }
  }
 } while(0);
 L151: do {
  if ((label|0) == 108) {
   $476 = HEAP32[(3632)>>2]|0;
   $477 = ($476>>>0)<($$0193>>>0);
   if (!($477)) {
    $478 = (($476) - ($$0193))|0;
    $479 = HEAP32[(3644)>>2]|0;
    $480 = ($478>>>0)>(15);
    if ($480) {
     $481 = (($479) + ($$0193)|0);
     HEAP32[(3644)>>2] = $481;
     HEAP32[(3632)>>2] = $478;
     $482 = $478 | 1;
     $483 = ((($481)) + 4|0);
     HEAP32[$483>>2] = $482;
     $484 = (($481) + ($478)|0);
     HEAP32[$484>>2] = $478;
     $485 = $$0193 | 3;
     $486 = ((($479)) + 4|0);
     HEAP32[$486>>2] = $485;
    } else {
     HEAP32[(3632)>>2] = 0;
     HEAP32[(3644)>>2] = 0;
     $487 = $476 | 3;
     $488 = ((($479)) + 4|0);
     HEAP32[$488>>2] = $487;
     $489 = (($479) + ($476)|0);
     $490 = ((($489)) + 4|0);
     $491 = HEAP32[$490>>2]|0;
     $492 = $491 | 1;
     HEAP32[$490>>2] = $492;
    }
    $493 = ((($479)) + 8|0);
    $$2 = $493;
    break;
   }
   $494 = HEAP32[(3636)>>2]|0;
   $495 = ($494>>>0)>($$0193>>>0);
   if ($495) {
    $496 = (($494) - ($$0193))|0;
    HEAP32[(3636)>>2] = $496;
    $497 = HEAP32[(3648)>>2]|0;
    $498 = (($497) + ($$0193)|0);
    HEAP32[(3648)>>2] = $498;
    $499 = $496 | 1;
    $500 = ((($498)) + 4|0);
    HEAP32[$500>>2] = $499;
    $501 = $$0193 | 3;
    $502 = ((($497)) + 4|0);
    HEAP32[$502>>2] = $501;
    $503 = ((($497)) + 8|0);
    $$2 = $503;
    break;
   }
   $504 = HEAP32[893]|0;
   $505 = ($504|0)==(0);
   if ($505) {
    (___pthread_mutex_lock(3596)|0);
    $506 = HEAP32[893]|0;
    $507 = ($506|0)==(0);
    if ($507) {
     HEAP32[(3580)>>2] = 4096;
     HEAP32[(3576)>>2] = 4096;
     HEAP32[(3584)>>2] = -1;
     HEAP32[(3588)>>2] = -1;
     HEAP32[(3592)>>2] = 2;
     HEAP32[(4068)>>2] = 2;
     $508 = (_pthread_mutexattr_init($1)|0);
     $509 = ($508|0)==(0);
     if ($509) {
      $510 = (_pthread_mutex_init((4072),$1)|0);
      $511 = ($510|0)==(0);
      if ($511) {
       (_pthread_mutexattr_destroy($1)|0);
      }
     }
     $512 = $2;
     $513 = $512 & -16;
     $514 = $513 ^ 1431655768;
     HEAP32[$2>>2] = $514;
     Atomics_store(HEAP32,893,$514)|0;
    }
    (___pthread_mutex_unlock(3596)|0);
   }
   $515 = (($$0193) + 48)|0;
   $516 = HEAP32[(3580)>>2]|0;
   $517 = (($$0193) + 47)|0;
   $518 = (($516) + ($517))|0;
   $519 = (0 - ($516))|0;
   $520 = $518 & $519;
   $521 = ($520>>>0)>($$0193>>>0);
   if ($521) {
    $522 = HEAP32[(4064)>>2]|0;
    $523 = ($522|0)==(0);
    if (!($523)) {
     $524 = HEAP32[(4056)>>2]|0;
     $525 = (($524) + ($520))|0;
     $526 = ($525>>>0)<=($524>>>0);
     $527 = ($525>>>0)>($522>>>0);
     $or$cond1$i = $526 | $527;
     if ($or$cond1$i) {
      $$2 = 0;
      break;
     }
    }
    $528 = HEAP32[(4068)>>2]|0;
    $529 = $528 & 4;
    $530 = ($529|0)==(0);
    if ($530) {
     $531 = HEAP32[(3648)>>2]|0;
     $532 = ($531|0)==(0|0);
     L179: do {
      if ($532) {
       label = 131;
      } else {
       $$0$i$i = (4100);
       while(1) {
        $533 = HEAP32[$$0$i$i>>2]|0;
        $534 = ($533>>>0)>($531>>>0);
        if (!($534)) {
         $535 = ((($$0$i$i)) + 4|0);
         $536 = HEAP32[$535>>2]|0;
         $537 = (($533) + ($536)|0);
         $538 = ($537>>>0)>($531>>>0);
         if ($538) {
          break;
         }
        }
        $539 = ((($$0$i$i)) + 8|0);
        $540 = HEAP32[$539>>2]|0;
        $541 = ($540|0)==(0|0);
        if ($541) {
         label = 131;
         break L179;
        } else {
         $$0$i$i = $540;
        }
       }
       (___pthread_mutex_lock(3596)|0);
       $564 = HEAP32[(3636)>>2]|0;
       $565 = HEAP32[(3580)>>2]|0;
       $566 = (($517) - ($564))|0;
       $567 = (($566) + ($565))|0;
       $568 = (0 - ($565))|0;
       $569 = $567 & $568;
       $570 = ($569>>>0)<(2147483647);
       if ($570) {
        $571 = (_sbrk(($569|0))|0);
        $572 = HEAP32[$$0$i$i>>2]|0;
        $573 = HEAP32[$535>>2]|0;
        $574 = (($572) + ($573)|0);
        $575 = ($571|0)==($574|0);
        if ($575) {
         $576 = ($571|0)==((-1)|0);
         if ($576) {
          $$2234243136$i = $569;
          label = 145;
         } else {
          $$3229$i = $571;$$3235$i = $569;
         }
        } else {
         $$2247$ph$i = $571;$$2253$ph$i = $569;
         label = 139;
        }
       } else {
        $$2234243136$i = 0;
        label = 145;
       }
      }
     } while(0);
     do {
      if ((label|0) == 131) {
       (___pthread_mutex_lock(3596)|0);
       $542 = (_sbrk(0)|0);
       $543 = ($542|0)==((-1)|0);
       if ($543) {
        $$2234243136$i = 0;
        label = 145;
       } else {
        $544 = $542;
        $545 = HEAP32[(3576)>>2]|0;
        $546 = (($545) + -1)|0;
        $547 = $546 & $544;
        $548 = ($547|0)==(0);
        $549 = (($546) + ($544))|0;
        $550 = (0 - ($545))|0;
        $551 = $549 & $550;
        $552 = (($551) - ($544))|0;
        $553 = $548 ? 0 : $552;
        $$$i = (($553) + ($520))|0;
        $554 = HEAP32[(4056)>>2]|0;
        $555 = (($$$i) + ($554))|0;
        $556 = ($$$i>>>0)>($$0193>>>0);
        $557 = ($$$i>>>0)<(2147483647);
        $or$cond$i207 = $556 & $557;
        if ($or$cond$i207) {
         $558 = HEAP32[(4064)>>2]|0;
         $559 = ($558|0)==(0);
         if (!($559)) {
          $560 = ($555>>>0)<=($554>>>0);
          $561 = ($555>>>0)>($558>>>0);
          $or$cond2$i208 = $560 | $561;
          if ($or$cond2$i208) {
           $$2234243136$i = 0;
           label = 145;
           break;
          }
         }
         $562 = (_sbrk(($$$i|0))|0);
         $563 = ($562|0)==($542|0);
         if ($563) {
          $$3229$i = $542;$$3235$i = $$$i;
         } else {
          $$2247$ph$i = $562;$$2253$ph$i = $$$i;
          label = 139;
         }
        } else {
         $$2234243136$i = 0;
         label = 145;
        }
       }
      }
     } while(0);
     do {
      if ((label|0) == 139) {
       $577 = (0 - ($$2253$ph$i))|0;
       $578 = ($$2247$ph$i|0)!=((-1)|0);
       $579 = ($$2253$ph$i>>>0)<(2147483647);
       $or$cond7$i = $579 & $578;
       $580 = ($515>>>0)>($$2253$ph$i>>>0);
       $or$cond10$i = $580 & $or$cond7$i;
       if (!($or$cond10$i)) {
        $590 = ($$2247$ph$i|0)==((-1)|0);
        if ($590) {
         $$2234243136$i = 0;
         label = 145;
         break;
        } else {
         $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
         break;
        }
       }
       $581 = HEAP32[(3580)>>2]|0;
       $582 = (($517) - ($$2253$ph$i))|0;
       $583 = (($582) + ($581))|0;
       $584 = (0 - ($581))|0;
       $585 = $583 & $584;
       $586 = ($585>>>0)<(2147483647);
       if ($586) {
        $587 = (_sbrk(($585|0))|0);
        $588 = ($587|0)==((-1)|0);
        if ($588) {
         (_sbrk(($577|0))|0);
         $$2234243136$i = 0;
         label = 145;
         break;
        } else {
         $589 = (($585) + ($$2253$ph$i))|0;
         $$3229$i = $$2247$ph$i;$$3235$i = $589;
         break;
        }
       } else {
        $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
       }
      }
     } while(0);
     if ((label|0) == 145) {
      $591 = HEAP32[(4068)>>2]|0;
      $592 = $591 | 4;
      HEAP32[(4068)>>2] = $592;
      $$3229$i = (-1);$$3235$i = $$2234243136$i;
     }
     (___pthread_mutex_unlock(3596)|0);
     $$4230$i = $$3229$i;$$4236$i = $$3235$i;
    } else {
     $$4230$i = (-1);$$4236$i = 0;
    }
    $593 = ($$4230$i|0)==((-1)|0);
    $594 = ($520>>>0)<(2147483647);
    $or$cond9$i = $594 & $593;
    if ($or$cond9$i) {
     (___pthread_mutex_lock(3596)|0);
     $595 = (_sbrk(($520|0))|0);
     $596 = (_sbrk(0)|0);
     (___pthread_mutex_unlock(3596)|0);
     $597 = ($595|0)!=((-1)|0);
     $598 = ($596|0)!=((-1)|0);
     $or$cond5$i = $597 & $598;
     $599 = ($595>>>0)<($596>>>0);
     $or$cond11$i = $599 & $or$cond5$i;
     $600 = $596;
     $601 = $595;
     $602 = (($600) - ($601))|0;
     $603 = (($$0193) + 40)|0;
     $604 = ($602>>>0)>($603>>>0);
     $$$4236$i = $604 ? $602 : $$4236$i;
     $$$4230$i = $604 ? $595 : (-1);
     if ($or$cond11$i) {
      $$7$i = $$$4230$i;$$7239$i = $$$4236$i;
      label = 149;
     }
    } else {
     $$7$i = $$4230$i;$$7239$i = $$4236$i;
     label = 149;
    }
    if ((label|0) == 149) {
     $605 = ($$7$i|0)==((-1)|0);
     if (!($605)) {
      $606 = HEAP32[(4056)>>2]|0;
      $607 = (($606) + ($$7239$i))|0;
      HEAP32[(4056)>>2] = $607;
      $608 = HEAP32[(4060)>>2]|0;
      $609 = ($607>>>0)>($608>>>0);
      if ($609) {
       HEAP32[(4060)>>2] = $607;
      }
      $610 = HEAP32[(3648)>>2]|0;
      $611 = ($610|0)==(0|0);
      do {
       if ($611) {
        $612 = HEAP32[(3640)>>2]|0;
        $613 = ($612|0)==(0|0);
        $614 = ($$7$i>>>0)<($612>>>0);
        $or$cond12$i = $613 | $614;
        if ($or$cond12$i) {
         HEAP32[(3640)>>2] = $$7$i;
        }
        HEAP32[(4100)>>2] = $$7$i;
        HEAP32[(4104)>>2] = $$7239$i;
        HEAP32[(4112)>>2] = 0;
        $615 = HEAP32[893]|0;
        HEAP32[(3660)>>2] = $615;
        HEAP32[(3656)>>2] = -1;
        $$01$i$i = 0;
        while(1) {
         $616 = $$01$i$i << 1;
         $617 = (3664 + ($616<<2)|0);
         $618 = ((($617)) + 12|0);
         HEAP32[$618>>2] = $617;
         $619 = ((($617)) + 8|0);
         HEAP32[$619>>2] = $617;
         $620 = (($$01$i$i) + 1)|0;
         $exitcond$i$i = ($620|0)==(32);
         if ($exitcond$i$i) {
          break;
         } else {
          $$01$i$i = $620;
         }
        }
        $621 = (($$7239$i) + -40)|0;
        $622 = ((($$7$i)) + 8|0);
        $623 = $622;
        $624 = $623 & 7;
        $625 = ($624|0)==(0);
        $626 = (0 - ($623))|0;
        $627 = $626 & 7;
        $628 = $625 ? 0 : $627;
        $629 = (($$7$i) + ($628)|0);
        $630 = (($621) - ($628))|0;
        HEAP32[(3648)>>2] = $629;
        HEAP32[(3636)>>2] = $630;
        $631 = $630 | 1;
        $632 = ((($629)) + 4|0);
        HEAP32[$632>>2] = $631;
        $633 = (($629) + ($630)|0);
        $634 = ((($633)) + 4|0);
        HEAP32[$634>>2] = 40;
        $635 = HEAP32[(3588)>>2]|0;
        HEAP32[(3652)>>2] = $635;
       } else {
        $$024362$i = (4100);
        while(1) {
         $636 = HEAP32[$$024362$i>>2]|0;
         $637 = ((($$024362$i)) + 4|0);
         $638 = HEAP32[$637>>2]|0;
         $639 = (($636) + ($638)|0);
         $640 = ($$7$i|0)==($639|0);
         if ($640) {
          label = 160;
          break;
         }
         $641 = ((($$024362$i)) + 8|0);
         $642 = HEAP32[$641>>2]|0;
         $643 = ($642|0)==(0|0);
         if ($643) {
          break;
         } else {
          $$024362$i = $642;
         }
        }
        if ((label|0) == 160) {
         $644 = ((($$024362$i)) + 12|0);
         $645 = HEAP32[$644>>2]|0;
         $646 = $645 & 8;
         $647 = ($646|0)==(0);
         if ($647) {
          $648 = ($610>>>0)>=($636>>>0);
          $649 = ($610>>>0)<($$7$i>>>0);
          $or$cond42$i = $649 & $648;
          if ($or$cond42$i) {
           $650 = (($638) + ($$7239$i))|0;
           HEAP32[$637>>2] = $650;
           $651 = HEAP32[(3636)>>2]|0;
           $652 = ((($610)) + 8|0);
           $653 = $652;
           $654 = $653 & 7;
           $655 = ($654|0)==(0);
           $656 = (0 - ($653))|0;
           $657 = $656 & 7;
           $658 = $655 ? 0 : $657;
           $659 = (($610) + ($658)|0);
           $660 = (($$7239$i) - ($658))|0;
           $661 = (($651) + ($660))|0;
           HEAP32[(3648)>>2] = $659;
           HEAP32[(3636)>>2] = $661;
           $662 = $661 | 1;
           $663 = ((($659)) + 4|0);
           HEAP32[$663>>2] = $662;
           $664 = (($659) + ($661)|0);
           $665 = ((($664)) + 4|0);
           HEAP32[$665>>2] = 40;
           $666 = HEAP32[(3588)>>2]|0;
           HEAP32[(3652)>>2] = $666;
           break;
          }
         }
        }
        $667 = HEAP32[(3640)>>2]|0;
        $668 = ($$7$i>>>0)<($667>>>0);
        if ($668) {
         HEAP32[(3640)>>2] = $$7$i;
        }
        $669 = (($$7$i) + ($$7239$i)|0);
        $$124461$i = (4100);
        while(1) {
         $670 = HEAP32[$$124461$i>>2]|0;
         $671 = ($670|0)==($669|0);
         if ($671) {
          label = 168;
          break;
         }
         $672 = ((($$124461$i)) + 8|0);
         $673 = HEAP32[$672>>2]|0;
         $674 = ($673|0)==(0|0);
         if ($674) {
          break;
         } else {
          $$124461$i = $673;
         }
        }
        if ((label|0) == 168) {
         $675 = ((($$124461$i)) + 12|0);
         $676 = HEAP32[$675>>2]|0;
         $677 = $676 & 8;
         $678 = ($677|0)==(0);
         if ($678) {
          HEAP32[$$124461$i>>2] = $$7$i;
          $679 = ((($$124461$i)) + 4|0);
          $680 = HEAP32[$679>>2]|0;
          $681 = (($680) + ($$7239$i))|0;
          HEAP32[$679>>2] = $681;
          $682 = ((($$7$i)) + 8|0);
          $683 = $682;
          $684 = $683 & 7;
          $685 = ($684|0)==(0);
          $686 = (0 - ($683))|0;
          $687 = $686 & 7;
          $688 = $685 ? 0 : $687;
          $689 = (($$7$i) + ($688)|0);
          $690 = ((($669)) + 8|0);
          $691 = $690;
          $692 = $691 & 7;
          $693 = ($692|0)==(0);
          $694 = (0 - ($691))|0;
          $695 = $694 & 7;
          $696 = $693 ? 0 : $695;
          $697 = (($669) + ($696)|0);
          $698 = $697;
          $699 = $689;
          $700 = (($698) - ($699))|0;
          $701 = (($689) + ($$0193)|0);
          $702 = (($700) - ($$0193))|0;
          $703 = $$0193 | 3;
          $704 = ((($689)) + 4|0);
          HEAP32[$704>>2] = $703;
          $705 = ($697|0)==($610|0);
          do {
           if ($705) {
            $706 = HEAP32[(3636)>>2]|0;
            $707 = (($706) + ($702))|0;
            HEAP32[(3636)>>2] = $707;
            HEAP32[(3648)>>2] = $701;
            $708 = $707 | 1;
            $709 = ((($701)) + 4|0);
            HEAP32[$709>>2] = $708;
           } else {
            $710 = HEAP32[(3644)>>2]|0;
            $711 = ($697|0)==($710|0);
            if ($711) {
             $712 = HEAP32[(3632)>>2]|0;
             $713 = (($712) + ($702))|0;
             HEAP32[(3632)>>2] = $713;
             HEAP32[(3644)>>2] = $701;
             $714 = $713 | 1;
             $715 = ((($701)) + 4|0);
             HEAP32[$715>>2] = $714;
             $716 = (($701) + ($713)|0);
             HEAP32[$716>>2] = $713;
             break;
            }
            $717 = ((($697)) + 4|0);
            $718 = HEAP32[$717>>2]|0;
            $719 = $718 & 3;
            $720 = ($719|0)==(1);
            if ($720) {
             $721 = $718 & -8;
             $722 = $718 >>> 3;
             $723 = ($718>>>0)<(256);
             L250: do {
              if ($723) {
               $724 = ((($697)) + 8|0);
               $725 = HEAP32[$724>>2]|0;
               $726 = ((($697)) + 12|0);
               $727 = HEAP32[$726>>2]|0;
               $728 = ($727|0)==($725|0);
               if ($728) {
                $729 = 1 << $722;
                $730 = $729 ^ -1;
                $731 = HEAP32[906]|0;
                $732 = $731 & $730;
                HEAP32[906] = $732;
                break;
               } else {
                $733 = ((($725)) + 12|0);
                HEAP32[$733>>2] = $727;
                $734 = ((($727)) + 8|0);
                HEAP32[$734>>2] = $725;
                break;
               }
              } else {
               $735 = ((($697)) + 24|0);
               $736 = HEAP32[$735>>2]|0;
               $737 = ((($697)) + 12|0);
               $738 = HEAP32[$737>>2]|0;
               $739 = ($738|0)==($697|0);
               do {
                if ($739) {
                 $744 = ((($697)) + 16|0);
                 $745 = ((($744)) + 4|0);
                 $746 = HEAP32[$745>>2]|0;
                 $747 = ($746|0)==(0|0);
                 if ($747) {
                  $748 = HEAP32[$744>>2]|0;
                  $749 = ($748|0)==(0|0);
                  if ($749) {
                   $$3$i$i = 0;
                   break;
                  } else {
                   $$1264$i$i = $748;$$1266$i$i = $744;
                  }
                 } else {
                  $$1264$i$i = $746;$$1266$i$i = $745;
                 }
                 while(1) {
                  $750 = ((($$1264$i$i)) + 20|0);
                  $751 = HEAP32[$750>>2]|0;
                  $752 = ($751|0)==(0|0);
                  if (!($752)) {
                   $$1264$i$i = $751;$$1266$i$i = $750;
                   continue;
                  }
                  $753 = ((($$1264$i$i)) + 16|0);
                  $754 = HEAP32[$753>>2]|0;
                  $755 = ($754|0)==(0|0);
                  if ($755) {
                   break;
                  } else {
                   $$1264$i$i = $754;$$1266$i$i = $753;
                  }
                 }
                 HEAP32[$$1266$i$i>>2] = 0;
                 $$3$i$i = $$1264$i$i;
                } else {
                 $740 = ((($697)) + 8|0);
                 $741 = HEAP32[$740>>2]|0;
                 $742 = ((($741)) + 12|0);
                 HEAP32[$742>>2] = $738;
                 $743 = ((($738)) + 8|0);
                 HEAP32[$743>>2] = $741;
                 $$3$i$i = $738;
                }
               } while(0);
               $756 = ($736|0)==(0|0);
               if ($756) {
                break;
               }
               $757 = ((($697)) + 28|0);
               $758 = HEAP32[$757>>2]|0;
               $759 = (3928 + ($758<<2)|0);
               $760 = HEAP32[$759>>2]|0;
               $761 = ($697|0)==($760|0);
               do {
                if ($761) {
                 HEAP32[$759>>2] = $$3$i$i;
                 $cond$i$i = ($$3$i$i|0)==(0|0);
                 if (!($cond$i$i)) {
                  break;
                 }
                 $762 = 1 << $758;
                 $763 = $762 ^ -1;
                 $764 = HEAP32[(3628)>>2]|0;
                 $765 = $764 & $763;
                 HEAP32[(3628)>>2] = $765;
                 break L250;
                } else {
                 $766 = ((($736)) + 16|0);
                 $767 = HEAP32[$766>>2]|0;
                 $not$$i$i = ($767|0)!=($697|0);
                 $$sink1$i$i = $not$$i$i&1;
                 $768 = (((($736)) + 16|0) + ($$sink1$i$i<<2)|0);
                 HEAP32[$768>>2] = $$3$i$i;
                 $769 = ($$3$i$i|0)==(0|0);
                 if ($769) {
                  break L250;
                 }
                }
               } while(0);
               $770 = ((($$3$i$i)) + 24|0);
               HEAP32[$770>>2] = $736;
               $771 = ((($697)) + 16|0);
               $772 = HEAP32[$771>>2]|0;
               $773 = ($772|0)==(0|0);
               if (!($773)) {
                $774 = ((($$3$i$i)) + 16|0);
                HEAP32[$774>>2] = $772;
                $775 = ((($772)) + 24|0);
                HEAP32[$775>>2] = $$3$i$i;
               }
               $776 = ((($771)) + 4|0);
               $777 = HEAP32[$776>>2]|0;
               $778 = ($777|0)==(0|0);
               if ($778) {
                break;
               }
               $779 = ((($$3$i$i)) + 20|0);
               HEAP32[$779>>2] = $777;
               $780 = ((($777)) + 24|0);
               HEAP32[$780>>2] = $$3$i$i;
              }
             } while(0);
             $781 = (($697) + ($721)|0);
             $782 = (($721) + ($702))|0;
             $$0$i17$i = $781;$$0260$i$i = $782;
            } else {
             $$0$i17$i = $697;$$0260$i$i = $702;
            }
            $783 = ((($$0$i17$i)) + 4|0);
            $784 = HEAP32[$783>>2]|0;
            $785 = $784 & -2;
            HEAP32[$783>>2] = $785;
            $786 = $$0260$i$i | 1;
            $787 = ((($701)) + 4|0);
            HEAP32[$787>>2] = $786;
            $788 = (($701) + ($$0260$i$i)|0);
            HEAP32[$788>>2] = $$0260$i$i;
            $789 = $$0260$i$i >>> 3;
            $790 = ($$0260$i$i>>>0)<(256);
            if ($790) {
             $791 = $789 << 1;
             $792 = (3664 + ($791<<2)|0);
             $793 = HEAP32[906]|0;
             $794 = 1 << $789;
             $795 = $793 & $794;
             $796 = ($795|0)==(0);
             if ($796) {
              $797 = $793 | $794;
              HEAP32[906] = $797;
              $$pre$i$i = ((($792)) + 8|0);
              $$0268$i$i = $792;$$pre$phi$i$iZ2D = $$pre$i$i;
             } else {
              $798 = ((($792)) + 8|0);
              $799 = HEAP32[$798>>2]|0;
              $$0268$i$i = $799;$$pre$phi$i$iZ2D = $798;
             }
             HEAP32[$$pre$phi$i$iZ2D>>2] = $701;
             $800 = ((($$0268$i$i)) + 12|0);
             HEAP32[$800>>2] = $701;
             $801 = ((($701)) + 8|0);
             HEAP32[$801>>2] = $$0268$i$i;
             $802 = ((($701)) + 12|0);
             HEAP32[$802>>2] = $792;
             break;
            }
            $803 = $$0260$i$i >>> 8;
            $804 = ($803|0)==(0);
            do {
             if ($804) {
              $$0269$i$i = 0;
             } else {
              $805 = ($$0260$i$i>>>0)>(16777215);
              if ($805) {
               $$0269$i$i = 31;
               break;
              }
              $806 = (($803) + 1048320)|0;
              $807 = $806 >>> 16;
              $808 = $807 & 8;
              $809 = $803 << $808;
              $810 = (($809) + 520192)|0;
              $811 = $810 >>> 16;
              $812 = $811 & 4;
              $813 = $812 | $808;
              $814 = $809 << $812;
              $815 = (($814) + 245760)|0;
              $816 = $815 >>> 16;
              $817 = $816 & 2;
              $818 = $813 | $817;
              $819 = (14 - ($818))|0;
              $820 = $814 << $817;
              $821 = $820 >>> 15;
              $822 = (($819) + ($821))|0;
              $823 = $822 << 1;
              $824 = (($822) + 7)|0;
              $825 = $$0260$i$i >>> $824;
              $826 = $825 & 1;
              $827 = $826 | $823;
              $$0269$i$i = $827;
             }
            } while(0);
            $828 = (3928 + ($$0269$i$i<<2)|0);
            $829 = ((($701)) + 28|0);
            HEAP32[$829>>2] = $$0269$i$i;
            $830 = ((($701)) + 16|0);
            $831 = ((($830)) + 4|0);
            HEAP32[$831>>2] = 0;
            HEAP32[$830>>2] = 0;
            $832 = HEAP32[(3628)>>2]|0;
            $833 = 1 << $$0269$i$i;
            $834 = $832 & $833;
            $835 = ($834|0)==(0);
            if ($835) {
             $836 = $832 | $833;
             HEAP32[(3628)>>2] = $836;
             HEAP32[$828>>2] = $701;
             $837 = ((($701)) + 24|0);
             HEAP32[$837>>2] = $828;
             $838 = ((($701)) + 12|0);
             HEAP32[$838>>2] = $701;
             $839 = ((($701)) + 8|0);
             HEAP32[$839>>2] = $701;
             break;
            }
            $840 = HEAP32[$828>>2]|0;
            $841 = ($$0269$i$i|0)==(31);
            $842 = $$0269$i$i >>> 1;
            $843 = (25 - ($842))|0;
            $844 = $841 ? 0 : $843;
            $845 = $$0260$i$i << $844;
            $$0261$i$i = $845;$$0262$i$i = $840;
            while(1) {
             $846 = ((($$0262$i$i)) + 4|0);
             $847 = HEAP32[$846>>2]|0;
             $848 = $847 & -8;
             $849 = ($848|0)==($$0260$i$i|0);
             if ($849) {
              label = 209;
              break;
             }
             $850 = $$0261$i$i >>> 31;
             $851 = (((($$0262$i$i)) + 16|0) + ($850<<2)|0);
             $852 = $$0261$i$i << 1;
             $853 = HEAP32[$851>>2]|0;
             $854 = ($853|0)==(0|0);
             if ($854) {
              label = 208;
              break;
             } else {
              $$0261$i$i = $852;$$0262$i$i = $853;
             }
            }
            if ((label|0) == 208) {
             HEAP32[$851>>2] = $701;
             $855 = ((($701)) + 24|0);
             HEAP32[$855>>2] = $$0262$i$i;
             $856 = ((($701)) + 12|0);
             HEAP32[$856>>2] = $701;
             $857 = ((($701)) + 8|0);
             HEAP32[$857>>2] = $701;
             break;
            }
            else if ((label|0) == 209) {
             $858 = ((($$0262$i$i)) + 8|0);
             $859 = HEAP32[$858>>2]|0;
             $860 = ((($859)) + 12|0);
             HEAP32[$860>>2] = $701;
             HEAP32[$858>>2] = $701;
             $861 = ((($701)) + 8|0);
             HEAP32[$861>>2] = $859;
             $862 = ((($701)) + 12|0);
             HEAP32[$862>>2] = $$0262$i$i;
             $863 = ((($701)) + 24|0);
             HEAP32[$863>>2] = 0;
             break;
            }
           }
          } while(0);
          $988 = ((($689)) + 8|0);
          $$2 = $988;
          break L151;
         }
        }
        $$0$i$i$i = (4100);
        while(1) {
         $864 = HEAP32[$$0$i$i$i>>2]|0;
         $865 = ($864>>>0)>($610>>>0);
         if (!($865)) {
          $866 = ((($$0$i$i$i)) + 4|0);
          $867 = HEAP32[$866>>2]|0;
          $868 = (($864) + ($867)|0);
          $869 = ($868>>>0)>($610>>>0);
          if ($869) {
           break;
          }
         }
         $870 = ((($$0$i$i$i)) + 8|0);
         $871 = HEAP32[$870>>2]|0;
         $$0$i$i$i = $871;
        }
        $872 = ((($868)) + -47|0);
        $873 = ((($872)) + 8|0);
        $874 = $873;
        $875 = $874 & 7;
        $876 = ($875|0)==(0);
        $877 = (0 - ($874))|0;
        $878 = $877 & 7;
        $879 = $876 ? 0 : $878;
        $880 = (($872) + ($879)|0);
        $881 = ((($610)) + 16|0);
        $882 = ($880>>>0)<($881>>>0);
        $883 = $882 ? $610 : $880;
        $884 = ((($883)) + 8|0);
        $885 = ((($883)) + 24|0);
        $886 = (($$7239$i) + -40)|0;
        $887 = ((($$7$i)) + 8|0);
        $888 = $887;
        $889 = $888 & 7;
        $890 = ($889|0)==(0);
        $891 = (0 - ($888))|0;
        $892 = $891 & 7;
        $893 = $890 ? 0 : $892;
        $894 = (($$7$i) + ($893)|0);
        $895 = (($886) - ($893))|0;
        HEAP32[(3648)>>2] = $894;
        HEAP32[(3636)>>2] = $895;
        $896 = $895 | 1;
        $897 = ((($894)) + 4|0);
        HEAP32[$897>>2] = $896;
        $898 = (($894) + ($895)|0);
        $899 = ((($898)) + 4|0);
        HEAP32[$899>>2] = 40;
        $900 = HEAP32[(3588)>>2]|0;
        HEAP32[(3652)>>2] = $900;
        $901 = ((($883)) + 4|0);
        HEAP32[$901>>2] = 27;
        ;HEAP32[$884>>2]=HEAP32[(4100)>>2]|0;HEAP32[$884+4>>2]=HEAP32[(4100)+4>>2]|0;HEAP32[$884+8>>2]=HEAP32[(4100)+8>>2]|0;HEAP32[$884+12>>2]=HEAP32[(4100)+12>>2]|0;
        HEAP32[(4100)>>2] = $$7$i;
        HEAP32[(4104)>>2] = $$7239$i;
        HEAP32[(4112)>>2] = 0;
        HEAP32[(4108)>>2] = $884;
        $903 = $885;
        while(1) {
         $902 = ((($903)) + 4|0);
         HEAP32[$902>>2] = 7;
         $904 = ((($903)) + 8|0);
         $905 = ($904>>>0)<($868>>>0);
         if ($905) {
          $903 = $902;
         } else {
          break;
         }
        }
        $906 = ($883|0)==($610|0);
        if (!($906)) {
         $907 = $883;
         $908 = $610;
         $909 = (($907) - ($908))|0;
         $910 = HEAP32[$901>>2]|0;
         $911 = $910 & -2;
         HEAP32[$901>>2] = $911;
         $912 = $909 | 1;
         $913 = ((($610)) + 4|0);
         HEAP32[$913>>2] = $912;
         HEAP32[$883>>2] = $909;
         $914 = $909 >>> 3;
         $915 = ($909>>>0)<(256);
         if ($915) {
          $916 = $914 << 1;
          $917 = (3664 + ($916<<2)|0);
          $918 = HEAP32[906]|0;
          $919 = 1 << $914;
          $920 = $918 & $919;
          $921 = ($920|0)==(0);
          if ($921) {
           $922 = $918 | $919;
           HEAP32[906] = $922;
           $$pre$i18$i = ((($917)) + 8|0);
           $$0206$i$i = $917;$$pre$phi$i19$iZ2D = $$pre$i18$i;
          } else {
           $923 = ((($917)) + 8|0);
           $924 = HEAP32[$923>>2]|0;
           $$0206$i$i = $924;$$pre$phi$i19$iZ2D = $923;
          }
          HEAP32[$$pre$phi$i19$iZ2D>>2] = $610;
          $925 = ((($$0206$i$i)) + 12|0);
          HEAP32[$925>>2] = $610;
          $926 = ((($610)) + 8|0);
          HEAP32[$926>>2] = $$0206$i$i;
          $927 = ((($610)) + 12|0);
          HEAP32[$927>>2] = $917;
          break;
         }
         $928 = $909 >>> 8;
         $929 = ($928|0)==(0);
         do {
          if ($929) {
           $$0207$i$i = 0;
          } else {
           $930 = ($909>>>0)>(16777215);
           if ($930) {
            $$0207$i$i = 31;
            break;
           }
           $931 = (($928) + 1048320)|0;
           $932 = $931 >>> 16;
           $933 = $932 & 8;
           $934 = $928 << $933;
           $935 = (($934) + 520192)|0;
           $936 = $935 >>> 16;
           $937 = $936 & 4;
           $938 = $937 | $933;
           $939 = $934 << $937;
           $940 = (($939) + 245760)|0;
           $941 = $940 >>> 16;
           $942 = $941 & 2;
           $943 = $938 | $942;
           $944 = (14 - ($943))|0;
           $945 = $939 << $942;
           $946 = $945 >>> 15;
           $947 = (($944) + ($946))|0;
           $948 = $947 << 1;
           $949 = (($947) + 7)|0;
           $950 = $909 >>> $949;
           $951 = $950 & 1;
           $952 = $951 | $948;
           $$0207$i$i = $952;
          }
         } while(0);
         $953 = (3928 + ($$0207$i$i<<2)|0);
         $954 = ((($610)) + 28|0);
         HEAP32[$954>>2] = $$0207$i$i;
         $955 = ((($610)) + 20|0);
         HEAP32[$955>>2] = 0;
         HEAP32[$881>>2] = 0;
         $956 = HEAP32[(3628)>>2]|0;
         $957 = 1 << $$0207$i$i;
         $958 = $956 & $957;
         $959 = ($958|0)==(0);
         if ($959) {
          $960 = $956 | $957;
          HEAP32[(3628)>>2] = $960;
          HEAP32[$953>>2] = $610;
          $961 = ((($610)) + 24|0);
          HEAP32[$961>>2] = $953;
          $962 = ((($610)) + 12|0);
          HEAP32[$962>>2] = $610;
          $963 = ((($610)) + 8|0);
          HEAP32[$963>>2] = $610;
          break;
         }
         $964 = HEAP32[$953>>2]|0;
         $965 = ($$0207$i$i|0)==(31);
         $966 = $$0207$i$i >>> 1;
         $967 = (25 - ($966))|0;
         $968 = $965 ? 0 : $967;
         $969 = $909 << $968;
         $$0201$i$i = $969;$$0202$i$i = $964;
         while(1) {
          $970 = ((($$0202$i$i)) + 4|0);
          $971 = HEAP32[$970>>2]|0;
          $972 = $971 & -8;
          $973 = ($972|0)==($909|0);
          if ($973) {
           label = 231;
           break;
          }
          $974 = $$0201$i$i >>> 31;
          $975 = (((($$0202$i$i)) + 16|0) + ($974<<2)|0);
          $976 = $$0201$i$i << 1;
          $977 = HEAP32[$975>>2]|0;
          $978 = ($977|0)==(0|0);
          if ($978) {
           label = 230;
           break;
          } else {
           $$0201$i$i = $976;$$0202$i$i = $977;
          }
         }
         if ((label|0) == 230) {
          HEAP32[$975>>2] = $610;
          $979 = ((($610)) + 24|0);
          HEAP32[$979>>2] = $$0202$i$i;
          $980 = ((($610)) + 12|0);
          HEAP32[$980>>2] = $610;
          $981 = ((($610)) + 8|0);
          HEAP32[$981>>2] = $610;
          break;
         }
         else if ((label|0) == 231) {
          $982 = ((($$0202$i$i)) + 8|0);
          $983 = HEAP32[$982>>2]|0;
          $984 = ((($983)) + 12|0);
          HEAP32[$984>>2] = $610;
          HEAP32[$982>>2] = $610;
          $985 = ((($610)) + 8|0);
          HEAP32[$985>>2] = $983;
          $986 = ((($610)) + 12|0);
          HEAP32[$986>>2] = $$0202$i$i;
          $987 = ((($610)) + 24|0);
          HEAP32[$987>>2] = 0;
          break;
         }
        }
       }
      } while(0);
      $989 = HEAP32[(3636)>>2]|0;
      $990 = ($989>>>0)>($$0193>>>0);
      if ($990) {
       $991 = (($989) - ($$0193))|0;
       HEAP32[(3636)>>2] = $991;
       $992 = HEAP32[(3648)>>2]|0;
       $993 = (($992) + ($$0193)|0);
       HEAP32[(3648)>>2] = $993;
       $994 = $991 | 1;
       $995 = ((($993)) + 4|0);
       HEAP32[$995>>2] = $994;
       $996 = $$0193 | 3;
       $997 = ((($992)) + 4|0);
       HEAP32[$997>>2] = $996;
       $998 = ((($992)) + 8|0);
       $$2 = $998;
       break;
      }
     }
    }
    $999 = (___errno_location()|0);
    HEAP32[$999>>2] = 12;
    $$2 = 0;
   } else {
    $$2 = 0;
   }
  }
 } while(0);
 $1000 = HEAP32[(4068)>>2]|0;
 $1001 = $1000 & 2;
 $1002 = ($1001|0)==(0);
 if ($1002) {
  $$1 = $$2;
  STACKTOP = sp;return ($$1|0);
 }
 (___pthread_mutex_unlock((4072))|0);
 $$1 = $$2;
 STACKTOP = sp;return ($$1|0);
}
function _free($0) {
 $0 = $0|0;
 var $$0195$i = 0, $$0195$in$i = 0, $$0348 = 0, $$0349 = 0, $$0361 = 0, $$0368 = 0, $$1 = 0, $$1347 = 0, $$1352 = 0, $$1355 = 0, $$1363 = 0, $$1367 = 0, $$2 = 0, $$3 = 0, $$3365 = 0, $$pre = 0, $$pre$phiZ2D = 0, $$sink3 = 0, $$sink5 = 0, $1 = 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0;
 var $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0;
 var $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0;
 var $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0;
 var $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0;
 var $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0;
 var $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0;
 var $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0;
 var $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0;
 var $262 = 0, $263 = 0, $264 = 0, $265 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0;
 var $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0;
 var $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0;
 var $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0;
 var $96 = 0, $97 = 0, $98 = 0, $99 = 0, $cond374 = 0, $cond375 = 0, $not$ = 0, $not$370 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ($0|0)==(0|0);
 if ($1) {
  return;
 }
 $2 = ((($0)) + -8|0);
 $3 = HEAP32[(4068)>>2]|0;
 $4 = $3 & 2;
 $5 = ($4|0)==(0);
 if (!($5)) {
  $6 = (___pthread_mutex_lock((4072))|0);
  $7 = ($6|0)==(0);
  if (!($7)) {
   return;
  }
 }
 $8 = HEAP32[(3640)>>2]|0;
 $9 = ((($0)) + -4|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = $10 & -8;
 $12 = (($2) + ($11)|0);
 $13 = $10 & 1;
 $14 = ($13|0)==(0);
 do {
  if ($14) {
   $15 = HEAP32[$2>>2]|0;
   $16 = $10 & 3;
   $17 = ($16|0)==(0);
   if (!($17)) {
    $18 = (0 - ($15))|0;
    $19 = (($2) + ($18)|0);
    $20 = (($15) + ($11))|0;
    $21 = ($19>>>0)<($8>>>0);
    if (!($21)) {
     $22 = HEAP32[(3644)>>2]|0;
     $23 = ($19|0)==($22|0);
     if ($23) {
      $83 = ((($12)) + 4|0);
      $84 = HEAP32[$83>>2]|0;
      $85 = $84 & 3;
      $86 = ($85|0)==(3);
      if (!($86)) {
       $$1 = $19;$$1347 = $20;$91 = $19;
       label = 30;
       break;
      }
      $87 = (($19) + ($20)|0);
      $88 = ((($19)) + 4|0);
      $89 = $20 | 1;
      $90 = $84 & -2;
      HEAP32[(3632)>>2] = $20;
      HEAP32[$83>>2] = $90;
      HEAP32[$88>>2] = $89;
      HEAP32[$87>>2] = $20;
      break;
     }
     $24 = $15 >>> 3;
     $25 = ($15>>>0)<(256);
     if ($25) {
      $26 = ((($19)) + 8|0);
      $27 = HEAP32[$26>>2]|0;
      $28 = ((($19)) + 12|0);
      $29 = HEAP32[$28>>2]|0;
      $30 = ($29|0)==($27|0);
      if ($30) {
       $31 = 1 << $24;
       $32 = $31 ^ -1;
       $33 = HEAP32[906]|0;
       $34 = $33 & $32;
       HEAP32[906] = $34;
       $$1 = $19;$$1347 = $20;$91 = $19;
       label = 30;
       break;
      } else {
       $35 = ((($27)) + 12|0);
       HEAP32[$35>>2] = $29;
       $36 = ((($29)) + 8|0);
       HEAP32[$36>>2] = $27;
       $$1 = $19;$$1347 = $20;$91 = $19;
       label = 30;
       break;
      }
     }
     $37 = ((($19)) + 24|0);
     $38 = HEAP32[$37>>2]|0;
     $39 = ((($19)) + 12|0);
     $40 = HEAP32[$39>>2]|0;
     $41 = ($40|0)==($19|0);
     do {
      if ($41) {
       $46 = ((($19)) + 16|0);
       $47 = ((($46)) + 4|0);
       $48 = HEAP32[$47>>2]|0;
       $49 = ($48|0)==(0|0);
       if ($49) {
        $50 = HEAP32[$46>>2]|0;
        $51 = ($50|0)==(0|0);
        if ($51) {
         $$3 = 0;
         break;
        } else {
         $$1352 = $50;$$1355 = $46;
        }
       } else {
        $$1352 = $48;$$1355 = $47;
       }
       while(1) {
        $52 = ((($$1352)) + 20|0);
        $53 = HEAP32[$52>>2]|0;
        $54 = ($53|0)==(0|0);
        if (!($54)) {
         $$1352 = $53;$$1355 = $52;
         continue;
        }
        $55 = ((($$1352)) + 16|0);
        $56 = HEAP32[$55>>2]|0;
        $57 = ($56|0)==(0|0);
        if ($57) {
         break;
        } else {
         $$1352 = $56;$$1355 = $55;
        }
       }
       HEAP32[$$1355>>2] = 0;
       $$3 = $$1352;
      } else {
       $42 = ((($19)) + 8|0);
       $43 = HEAP32[$42>>2]|0;
       $44 = ((($43)) + 12|0);
       HEAP32[$44>>2] = $40;
       $45 = ((($40)) + 8|0);
       HEAP32[$45>>2] = $43;
       $$3 = $40;
      }
     } while(0);
     $58 = ($38|0)==(0|0);
     if ($58) {
      $$1 = $19;$$1347 = $20;$91 = $19;
      label = 30;
     } else {
      $59 = ((($19)) + 28|0);
      $60 = HEAP32[$59>>2]|0;
      $61 = (3928 + ($60<<2)|0);
      $62 = HEAP32[$61>>2]|0;
      $63 = ($19|0)==($62|0);
      if ($63) {
       HEAP32[$61>>2] = $$3;
       $cond374 = ($$3|0)==(0|0);
       if ($cond374) {
        $64 = 1 << $60;
        $65 = $64 ^ -1;
        $66 = HEAP32[(3628)>>2]|0;
        $67 = $66 & $65;
        HEAP32[(3628)>>2] = $67;
        $$1 = $19;$$1347 = $20;$91 = $19;
        label = 30;
        break;
       }
      } else {
       $68 = ((($38)) + 16|0);
       $69 = HEAP32[$68>>2]|0;
       $not$370 = ($69|0)!=($19|0);
       $$sink3 = $not$370&1;
       $70 = (((($38)) + 16|0) + ($$sink3<<2)|0);
       HEAP32[$70>>2] = $$3;
       $71 = ($$3|0)==(0|0);
       if ($71) {
        $$1 = $19;$$1347 = $20;$91 = $19;
        label = 30;
        break;
       }
      }
      $72 = ((($$3)) + 24|0);
      HEAP32[$72>>2] = $38;
      $73 = ((($19)) + 16|0);
      $74 = HEAP32[$73>>2]|0;
      $75 = ($74|0)==(0|0);
      if (!($75)) {
       $76 = ((($$3)) + 16|0);
       HEAP32[$76>>2] = $74;
       $77 = ((($74)) + 24|0);
       HEAP32[$77>>2] = $$3;
      }
      $78 = ((($73)) + 4|0);
      $79 = HEAP32[$78>>2]|0;
      $80 = ($79|0)==(0|0);
      if ($80) {
       $$1 = $19;$$1347 = $20;$91 = $19;
       label = 30;
      } else {
       $81 = ((($$3)) + 20|0);
       HEAP32[$81>>2] = $79;
       $82 = ((($79)) + 24|0);
       HEAP32[$82>>2] = $$3;
       $$1 = $19;$$1347 = $20;$91 = $19;
       label = 30;
      }
     }
    }
   }
  } else {
   $$1 = $2;$$1347 = $11;$91 = $2;
   label = 30;
  }
 } while(0);
 do {
  if ((label|0) == 30) {
   $92 = ($91>>>0)<($12>>>0);
   if ($92) {
    $93 = ((($12)) + 4|0);
    $94 = HEAP32[$93>>2]|0;
    $95 = $94 & 1;
    $96 = ($95|0)==(0);
    if (!($96)) {
     $97 = $94 & 2;
     $98 = ($97|0)==(0);
     if ($98) {
      $99 = HEAP32[(3648)>>2]|0;
      $100 = ($12|0)==($99|0);
      $101 = HEAP32[(3644)>>2]|0;
      if ($100) {
       $102 = HEAP32[(3636)>>2]|0;
       $103 = (($102) + ($$1347))|0;
       HEAP32[(3636)>>2] = $103;
       HEAP32[(3648)>>2] = $$1;
       $104 = $103 | 1;
       $105 = ((($$1)) + 4|0);
       HEAP32[$105>>2] = $104;
       $106 = ($$1|0)==($101|0);
       if (!($106)) {
        break;
       }
       HEAP32[(3644)>>2] = 0;
       HEAP32[(3632)>>2] = 0;
       break;
      }
      $107 = ($12|0)==($101|0);
      if ($107) {
       $108 = HEAP32[(3632)>>2]|0;
       $109 = (($108) + ($$1347))|0;
       HEAP32[(3632)>>2] = $109;
       HEAP32[(3644)>>2] = $91;
       $110 = $109 | 1;
       $111 = ((($$1)) + 4|0);
       HEAP32[$111>>2] = $110;
       $112 = (($91) + ($109)|0);
       HEAP32[$112>>2] = $109;
       break;
      }
      $113 = $94 & -8;
      $114 = (($113) + ($$1347))|0;
      $115 = $94 >>> 3;
      $116 = ($94>>>0)<(256);
      do {
       if ($116) {
        $117 = ((($12)) + 8|0);
        $118 = HEAP32[$117>>2]|0;
        $119 = ((($12)) + 12|0);
        $120 = HEAP32[$119>>2]|0;
        $121 = ($120|0)==($118|0);
        if ($121) {
         $122 = 1 << $115;
         $123 = $122 ^ -1;
         $124 = HEAP32[906]|0;
         $125 = $124 & $123;
         HEAP32[906] = $125;
         break;
        } else {
         $126 = ((($118)) + 12|0);
         HEAP32[$126>>2] = $120;
         $127 = ((($120)) + 8|0);
         HEAP32[$127>>2] = $118;
         break;
        }
       } else {
        $128 = ((($12)) + 24|0);
        $129 = HEAP32[$128>>2]|0;
        $130 = ((($12)) + 12|0);
        $131 = HEAP32[$130>>2]|0;
        $132 = ($131|0)==($12|0);
        do {
         if ($132) {
          $137 = ((($12)) + 16|0);
          $138 = ((($137)) + 4|0);
          $139 = HEAP32[$138>>2]|0;
          $140 = ($139|0)==(0|0);
          if ($140) {
           $141 = HEAP32[$137>>2]|0;
           $142 = ($141|0)==(0|0);
           if ($142) {
            $$3365 = 0;
            break;
           } else {
            $$1363 = $141;$$1367 = $137;
           }
          } else {
           $$1363 = $139;$$1367 = $138;
          }
          while(1) {
           $143 = ((($$1363)) + 20|0);
           $144 = HEAP32[$143>>2]|0;
           $145 = ($144|0)==(0|0);
           if (!($145)) {
            $$1363 = $144;$$1367 = $143;
            continue;
           }
           $146 = ((($$1363)) + 16|0);
           $147 = HEAP32[$146>>2]|0;
           $148 = ($147|0)==(0|0);
           if ($148) {
            break;
           } else {
            $$1363 = $147;$$1367 = $146;
           }
          }
          HEAP32[$$1367>>2] = 0;
          $$3365 = $$1363;
         } else {
          $133 = ((($12)) + 8|0);
          $134 = HEAP32[$133>>2]|0;
          $135 = ((($134)) + 12|0);
          HEAP32[$135>>2] = $131;
          $136 = ((($131)) + 8|0);
          HEAP32[$136>>2] = $134;
          $$3365 = $131;
         }
        } while(0);
        $149 = ($129|0)==(0|0);
        if (!($149)) {
         $150 = ((($12)) + 28|0);
         $151 = HEAP32[$150>>2]|0;
         $152 = (3928 + ($151<<2)|0);
         $153 = HEAP32[$152>>2]|0;
         $154 = ($12|0)==($153|0);
         if ($154) {
          HEAP32[$152>>2] = $$3365;
          $cond375 = ($$3365|0)==(0|0);
          if ($cond375) {
           $155 = 1 << $151;
           $156 = $155 ^ -1;
           $157 = HEAP32[(3628)>>2]|0;
           $158 = $157 & $156;
           HEAP32[(3628)>>2] = $158;
           break;
          }
         } else {
          $159 = ((($129)) + 16|0);
          $160 = HEAP32[$159>>2]|0;
          $not$ = ($160|0)!=($12|0);
          $$sink5 = $not$&1;
          $161 = (((($129)) + 16|0) + ($$sink5<<2)|0);
          HEAP32[$161>>2] = $$3365;
          $162 = ($$3365|0)==(0|0);
          if ($162) {
           break;
          }
         }
         $163 = ((($$3365)) + 24|0);
         HEAP32[$163>>2] = $129;
         $164 = ((($12)) + 16|0);
         $165 = HEAP32[$164>>2]|0;
         $166 = ($165|0)==(0|0);
         if (!($166)) {
          $167 = ((($$3365)) + 16|0);
          HEAP32[$167>>2] = $165;
          $168 = ((($165)) + 24|0);
          HEAP32[$168>>2] = $$3365;
         }
         $169 = ((($164)) + 4|0);
         $170 = HEAP32[$169>>2]|0;
         $171 = ($170|0)==(0|0);
         if (!($171)) {
          $172 = ((($$3365)) + 20|0);
          HEAP32[$172>>2] = $170;
          $173 = ((($170)) + 24|0);
          HEAP32[$173>>2] = $$3365;
         }
        }
       }
      } while(0);
      $174 = $114 | 1;
      $175 = ((($$1)) + 4|0);
      HEAP32[$175>>2] = $174;
      $176 = (($91) + ($114)|0);
      HEAP32[$176>>2] = $114;
      $177 = HEAP32[(3644)>>2]|0;
      $178 = ($$1|0)==($177|0);
      if ($178) {
       HEAP32[(3632)>>2] = $114;
       break;
      } else {
       $$2 = $114;
      }
     } else {
      $179 = $94 & -2;
      HEAP32[$93>>2] = $179;
      $180 = $$1347 | 1;
      $181 = ((($$1)) + 4|0);
      HEAP32[$181>>2] = $180;
      $182 = (($91) + ($$1347)|0);
      HEAP32[$182>>2] = $$1347;
      $$2 = $$1347;
     }
     $183 = $$2 >>> 3;
     $184 = ($$2>>>0)<(256);
     if ($184) {
      $185 = $183 << 1;
      $186 = (3664 + ($185<<2)|0);
      $187 = HEAP32[906]|0;
      $188 = 1 << $183;
      $189 = $187 & $188;
      $190 = ($189|0)==(0);
      if ($190) {
       $191 = $187 | $188;
       HEAP32[906] = $191;
       $$pre = ((($186)) + 8|0);
       $$0368 = $186;$$pre$phiZ2D = $$pre;
      } else {
       $192 = ((($186)) + 8|0);
       $193 = HEAP32[$192>>2]|0;
       $$0368 = $193;$$pre$phiZ2D = $192;
      }
      HEAP32[$$pre$phiZ2D>>2] = $$1;
      $194 = ((($$0368)) + 12|0);
      HEAP32[$194>>2] = $$1;
      $195 = ((($$1)) + 8|0);
      HEAP32[$195>>2] = $$0368;
      $196 = ((($$1)) + 12|0);
      HEAP32[$196>>2] = $186;
      break;
     }
     $197 = $$2 >>> 8;
     $198 = ($197|0)==(0);
     if ($198) {
      $$0361 = 0;
     } else {
      $199 = ($$2>>>0)>(16777215);
      if ($199) {
       $$0361 = 31;
      } else {
       $200 = (($197) + 1048320)|0;
       $201 = $200 >>> 16;
       $202 = $201 & 8;
       $203 = $197 << $202;
       $204 = (($203) + 520192)|0;
       $205 = $204 >>> 16;
       $206 = $205 & 4;
       $207 = $206 | $202;
       $208 = $203 << $206;
       $209 = (($208) + 245760)|0;
       $210 = $209 >>> 16;
       $211 = $210 & 2;
       $212 = $207 | $211;
       $213 = (14 - ($212))|0;
       $214 = $208 << $211;
       $215 = $214 >>> 15;
       $216 = (($213) + ($215))|0;
       $217 = $216 << 1;
       $218 = (($216) + 7)|0;
       $219 = $$2 >>> $218;
       $220 = $219 & 1;
       $221 = $220 | $217;
       $$0361 = $221;
      }
     }
     $222 = (3928 + ($$0361<<2)|0);
     $223 = ((($$1)) + 28|0);
     HEAP32[$223>>2] = $$0361;
     $224 = ((($$1)) + 16|0);
     $225 = ((($$1)) + 20|0);
     HEAP32[$225>>2] = 0;
     HEAP32[$224>>2] = 0;
     $226 = HEAP32[(3628)>>2]|0;
     $227 = 1 << $$0361;
     $228 = $226 & $227;
     $229 = ($228|0)==(0);
     do {
      if ($229) {
       $230 = $226 | $227;
       HEAP32[(3628)>>2] = $230;
       HEAP32[$222>>2] = $$1;
       $231 = ((($$1)) + 24|0);
       HEAP32[$231>>2] = $222;
       $232 = ((($$1)) + 12|0);
       HEAP32[$232>>2] = $$1;
       $233 = ((($$1)) + 8|0);
       HEAP32[$233>>2] = $$1;
      } else {
       $234 = HEAP32[$222>>2]|0;
       $235 = ($$0361|0)==(31);
       $236 = $$0361 >>> 1;
       $237 = (25 - ($236))|0;
       $238 = $235 ? 0 : $237;
       $239 = $$2 << $238;
       $$0348 = $239;$$0349 = $234;
       while(1) {
        $240 = ((($$0349)) + 4|0);
        $241 = HEAP32[$240>>2]|0;
        $242 = $241 & -8;
        $243 = ($242|0)==($$2|0);
        if ($243) {
         label = 75;
         break;
        }
        $244 = $$0348 >>> 31;
        $245 = (((($$0349)) + 16|0) + ($244<<2)|0);
        $246 = $$0348 << 1;
        $247 = HEAP32[$245>>2]|0;
        $248 = ($247|0)==(0|0);
        if ($248) {
         label = 74;
         break;
        } else {
         $$0348 = $246;$$0349 = $247;
        }
       }
       if ((label|0) == 74) {
        HEAP32[$245>>2] = $$1;
        $249 = ((($$1)) + 24|0);
        HEAP32[$249>>2] = $$0349;
        $250 = ((($$1)) + 12|0);
        HEAP32[$250>>2] = $$1;
        $251 = ((($$1)) + 8|0);
        HEAP32[$251>>2] = $$1;
        break;
       }
       else if ((label|0) == 75) {
        $252 = ((($$0349)) + 8|0);
        $253 = HEAP32[$252>>2]|0;
        $254 = ((($253)) + 12|0);
        HEAP32[$254>>2] = $$1;
        HEAP32[$252>>2] = $$1;
        $255 = ((($$1)) + 8|0);
        HEAP32[$255>>2] = $253;
        $256 = ((($$1)) + 12|0);
        HEAP32[$256>>2] = $$0349;
        $257 = ((($$1)) + 24|0);
        HEAP32[$257>>2] = 0;
        break;
       }
      }
     } while(0);
     $258 = HEAP32[(3656)>>2]|0;
     $259 = (($258) + -1)|0;
     HEAP32[(3656)>>2] = $259;
     $260 = ($259|0)==(0);
     if ($260) {
      $$0195$in$i = (4108);
      while(1) {
       $$0195$i = HEAP32[$$0195$in$i>>2]|0;
       $261 = ($$0195$i|0)==(0|0);
       $262 = ((($$0195$i)) + 8|0);
       if ($261) {
        break;
       } else {
        $$0195$in$i = $262;
       }
      }
      HEAP32[(3656)>>2] = -1;
     }
    }
   }
  }
 } while(0);
 $263 = HEAP32[(4068)>>2]|0;
 $264 = $263 & 2;
 $265 = ($264|0)==(0);
 if ($265) {
  return;
 }
 (___pthread_mutex_unlock((4072))|0);
 return;
}
function _sbrk(increment) {
    increment = increment|0;
    var oldDynamicTop = 0;
    var oldDynamicTopOnChange = 0;
    var newDynamicTop = 0;
    var totalMemory = 0;
    increment = ((increment + 15) & -16)|0;
    totalMemory = getTotalMemory()|0;

    // Perform a compare-and-swap loop to update the new dynamic top value. This is because
    // this function can becalled simultaneously in multiple threads.
    do {
      oldDynamicTop = Atomics_load(HEAP32, DYNAMICTOP_PTR>>2)|0;
      newDynamicTop = oldDynamicTop + increment | 0;
      // Asking to increase dynamic top to a too high value? In pthreads builds we cannot
      // enlarge memory, so this needs to fail.
      if (((increment|0) > 0 & (newDynamicTop|0) < (oldDynamicTop|0)) // Detect and fail if we would wrap around signed 32-bit int.
        | (newDynamicTop|0) < 0 // Also underflow, sbrk() should be able to be used to subtract.
        | (newDynamicTop|0) > (totalMemory|0)) {
        abortOnCannotGrowMemory()|0;
      }
      // Attempt to update the dynamic top to new value. Another thread may have beat this thread to the update,
      // in which case we will need to start over by iterating the loop body again.
      oldDynamicTopOnChange = Atomics_compareExchange(HEAP32, DYNAMICTOP_PTR>>2, oldDynamicTop|0, newDynamicTop|0)|0;
    } while((oldDynamicTopOnChange|0) != (oldDynamicTop|0));
    return oldDynamicTop|0;
}
function ___pthread_mutex_lock($0) {
 $0 = $0|0;
 var $$0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = HEAP32[$0>>2]|0;
 $2 = $1 & 15;
 $3 = ($2|0)==(0);
 if ($3) {
  $4 = ((($0)) + 4|0);
  $5 = (Atomics_compareExchange(HEAP32, $4>>2, 0, 16)|0);
  $6 = ($5|0)==(0);
  if ($6) {
   $$0 = 0;
   return ($$0|0);
  }
 }
 $7 = (___pthread_mutex_timedlock($0,0)|0);
 $$0 = $7;
 return ($$0|0);
}
function ___pthread_mutex_unlock($0) {
 $0 = $0|0;
 var $$0 = 0, $$045 = 0, $$pre = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0;
 var $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ((($0)) + 8|0);
 $2 = (Atomics_load(HEAP32,$1>>2)|0);
 $3 = HEAP32[$0>>2]|0;
 $4 = $3 & 15;
 $5 = $3 & 128;
 $6 = $5 ^ 128;
 $7 = ($4|0)==(0);
 if ($7) {
  $$pre = ((($0)) + 4|0);
  $$045 = 0;$$pre$phiZ2D = $$pre;
 } else {
  $8 = (_pthread_self()|0);
  $9 = ((($0)) + 4|0);
  $10 = (Atomics_load(HEAP32,$9>>2)|0);
  $11 = $10 & 2147483647;
  $12 = ((($8)) + 52|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ($11|0)==($13|0);
  if (!($14)) {
   $$0 = 1;
   return ($$0|0);
  }
  $15 = $3 & 3;
  $16 = ($15|0)==(1);
  if ($16) {
   $17 = ((($0)) + 20|0);
   $18 = HEAP32[$17>>2]|0;
   $19 = ($18|0)==(0);
   if (!($19)) {
    $20 = (($18) + -1)|0;
    HEAP32[$17>>2] = $20;
    $$0 = 0;
    return ($$0|0);
   }
  }
  $21 = ($6|0)==(0);
  $22 = ((($0)) + 16|0);
  if ($21) {
   $23 = ((($8)) + 176|0);
   Atomics_store(HEAP32,$23>>2,$22)|0;
   ___vm_lock();
  }
  $24 = ((($0)) + 12|0);
  $25 = HEAP32[$24>>2]|0;
  $26 = HEAP32[$22>>2]|0;
  Atomics_store(HEAP32,$25>>2,$26)|0;
  $27 = ((($8)) + 168|0);
  $28 = ($26|0)==($27|0);
  if ($28) {
   $$045 = $8;$$pre$phiZ2D = $9;
  } else {
   $29 = ((($26)) + -4|0);
   Atomics_store(HEAP32,$29>>2,$25)|0;
   $$045 = $8;$$pre$phiZ2D = $9;
  }
 }
 $30 = $3 & 8;
 $31 = ($30|0)!=(0);
 $32 = $31 ? 2147483647 : 0;
 while(1) {
  $33 = (Atomics_load(HEAP32, $$pre$phiZ2D>>2)|0);
  $34 = (Atomics_compareExchange(HEAP32, $$pre$phiZ2D>>2, $33, $32)|0);
  $35 = ($34|0)==($33|0);
  if ($35) {
   break;
  }
 }
 $36 = ($6|0)!=(0);
 $or$cond = $7 | $36;
 if (!($or$cond)) {
  $37 = ((($$045)) + 176|0);
  Atomics_store(HEAP32,$37>>2,0)|0;
  ___vm_unlock();
 }
 $38 = ($2|0)!=(0);
 $39 = ($33|0)<(0);
 $or$cond3 = $38 | $39;
 if (!($or$cond3)) {
  $$0 = 0;
  return ($$0|0);
 }
 (_emscripten_futex_wake(($$pre$phiZ2D|0),1)|0);
 $$0 = 0;
 return ($$0|0);
}
var Fetch = {
  attr_t_offset_requestMethod: 0,
  attr_t_offset_userData: 32,
  attr_t_offset_onsuccess: 36,
  attr_t_offset_onerror: 40,
  attr_t_offset_onprogress: 44,
  attr_t_offset_attributes: 48,
  attr_t_offset_timeoutMSecs: 52,
  attr_t_offset_withCredentials: 56,
  attr_t_offset_destinationPath: 60,
  attr_t_offset_userName: 64,
  attr_t_offset_password: 68,
  attr_t_offset_requestHeaders: 72,
  attr_t_offset_overriddenMimeType: 76,
  attr_t_offset_requestData: 80,
  attr_t_offset_requestDataSize: 84,

  fetch_t_offset_id: 0,
  fetch_t_offset_userData: 4,
  fetch_t_offset_url: 8,
  fetch_t_offset_data: 12,
  fetch_t_offset_numBytes: 16,
  fetch_t_offset_dataOffset: 24,
  fetch_t_offset_totalBytes: 32,
  fetch_t_offset_readyState: 40,
  fetch_t_offset_status: 42,
  fetch_t_offset_statusText: 44,
  fetch_t_offset___proxyState: 108,
  fetch_t_offset___attributes: 112,

  xhrs: [],
  // The web worker that runs proxied file I/O requests.
  worker: undefined,
  // Specifies an instance to the IndexedDB database. The database is opened
  // as a preload step before the Emscripten application starts.
  dbInstance: undefined,

  setu64: function(addr, val) {
    HEAPU32[addr >> 2] = val;
    HEAPU32[addr + 4 >> 2] = (val / 4294967296)|0;
  },

  openDatabase: function(dbname, dbversion, onsuccess, onerror) {
    try {

      console.log('fetch: indexedDB.open(dbname="' + dbname + '", dbversion="' + dbversion + '");');

      var openRequest = indexedDB.open(dbname, dbversion);
    } catch (e) { return onerror(e); }

    openRequest.onupgradeneeded = function(event) {

      console.log('fetch: IndexedDB upgrade needed. Clearing database.');

      var db = event.target.result;
      if (db.objectStoreNames.contains('FILES')) {
        db.deleteObjectStore('FILES');
      }
      db.createObjectStore('FILES');
    };
    openRequest.onsuccess = function(event) { onsuccess(event.target.result); };
    openRequest.onerror = function(error) { onerror(error); };
  },

  initFetchWorker: function() {
    var stackSize = 128*1024;
    var stack = allocate(stackSize>>2, "i32*", ALLOC_DYNAMIC);
    Fetch.worker.postMessage({cmd: 'init', TOTAL_MEMORY: TOTAL_MEMORY, DYNAMICTOP_PTR: DYNAMICTOP_PTR, STACKTOP: stack, STACK_MAX: stack + stackSize, queuePtr: _fetch_work_queue, buffer: HEAPU8.buffer});
  },

  staticInit: function() {



    var isMainThread = (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined');


    var onsuccess = function(db) {

      console.log('fetch: IndexedDB successfully opened.');

      Fetch.dbInstance = db;







      if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) removeRunDependency('library_fetch_init');

    };
    var onerror = function() {

      console.error('fetch: IndexedDB open failed.');

      Fetch.dbInstance = false;







    };
    Fetch.openDatabase('emscripten_filesystem', 1, onsuccess, onerror);
    if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) addRunDependency('library_fetch_init');

  }
}

function __emscripten_fetch_delete_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var request = packages.delete(pathStr);
    request.onsuccess = function(event) {
      var value = event.target.result;

      console.log('fetch: Deleted file ' + pathStr + ' from IndexedDB');

      HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
      Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, value);
    };
    request.onerror = function(error) {

      console.error('fetch: Failed to delete file ' + pathStr + ' from IndexedDB! error: ' + error);

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_load_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readonly');
    var packages = transaction.objectStore('FILES');
    var getRequest = packages.get(pathStr);
    getRequest.onsuccess = function(event) {
      if (event.target.result) {
        var value = event.target.result;
        var len = value.byteLength || value.length;

        console.log('fetch: Loaded file ' + pathStr + ' from IndexedDB, length: ' + len);


        // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
        // freed when emscripten_fetch_close() is called.
        var ptr = _malloc(len);
        HEAPU8.set(new Uint8Array(value), ptr);
        HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
        Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, len);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
        stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
        onsuccess(fetch, 0, value);
      } else {
        // Succeeded to load, but the load came back with the value of undefined, treat that as an error since we never store undefined in db.

        console.error('fetch: File ' + pathStr + ' not found in IndexedDB');

        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
        stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
        onerror(fetch, 0, 'no data');
      }
    };
    getRequest.onerror = function(error) {

      console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB!');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_cache_data(db, fetch, data, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!destinationPath) destinationPath = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var destinationPathStr = Pointer_stringify(destinationPath);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var putRequest = packages.put(data, destinationPathStr);
    putRequest.onsuccess = function(event) {

      console.log('fetch: Stored file "' + destinationPathStr + '" to IndexedDB cache.');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, destinationPathStr);
    };
    putRequest.onerror = function(error) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache!');

      // Most likely we got an error if IndexedDB is unwilling to store any more data for this page.
      // TODO: Can we identify and break down different IndexedDB-provided errors and convert those
      // to more HTTP status codes for more information?
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 413; // Mimic XHR HTTP status code 413 "Payload Too Large"
      stringToUTF8("Payload Too Large", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache! Exception: ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_xhr(fetch, onsuccess, onerror, onprogress) {
  var url = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  if (!url) {

    console.error('fetch: XHR failed, no URL specified!');

    onerror(fetch, 0, 'no url specified!');
    return;
  }
  var url_ = Pointer_stringify(url);

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  if (!requestMethod) requestMethod = 'GET';
  var userData = HEAPU32[fetch_attr + Fetch.attr_t_offset_userData >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var timeoutMsecs = HEAPU32[fetch_attr + Fetch.attr_t_offset_timeoutMSecs >> 2];
  var withCredentials = !!HEAPU32[fetch_attr + Fetch.attr_t_offset_withCredentials >> 2];
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  var userName = HEAPU32[fetch_attr + Fetch.attr_t_offset_userName >> 2];
  var password = HEAPU32[fetch_attr + Fetch.attr_t_offset_password >> 2];
  var requestHeaders = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestHeaders >> 2];
  var overriddenMimeType = HEAPU32[fetch_attr + Fetch.attr_t_offset_overriddenMimeType >> 2];
  var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
  var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];

  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);
  var fetchAttrSynchronous = !!(fetchAttributes & 64/*EMSCRIPTEN_FETCH_SYNCHRONOUS*/);
  var fetchAttrWaitable = !!(fetchAttributes & 128/*EMSCRIPTEN_FETCH_WAITABLE*/);

  var userNameStr = userName ? Pointer_stringify(userName) : undefined;
  var passwordStr = password ? Pointer_stringify(password) : undefined;
  var overriddenMimeTypeStr = overriddenMimeType ? Pointer_stringify(overriddenMimeType) : undefined;

  var xhr = new XMLHttpRequest();
  xhr.withCredentials = withCredentials;

  console.log('fetch: xhr.timeout: ' + xhr.timeout + ', xhr.withCredentials: ' + xhr.withCredentials);
  console.log('fetch: xhr.open(requestMethod="' + requestMethod + '", url: "' + url_ +'", userName: ' + userNameStr + ', password: ' + passwordStr + ');');

  xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
  if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; // XHR timeout field is only accessible in async XHRs, and must be set after .open() but before .send().
  xhr.url_ = url_; // Save the url for debugging purposes (and for comparing to the responseURL that server side advertised)
  xhr.responseType = fetchAttrStreamData ? 'moz-chunked-arraybuffer' : 'arraybuffer';

  if (overriddenMimeType) {

    console.log('fetch: xhr.overrideMimeType("' + overriddenMimeTypeStr + '");');

    xhr.overrideMimeType(overriddenMimeTypeStr);
  }
  if (requestHeaders) {
    for(;;) {
      var key = HEAPU32[requestHeaders >> 2];
      if (!key) break;
      var value = HEAPU32[requestHeaders + 4 >> 2];
      if (!value) break;
      requestHeaders += 8;
      var keyStr = Pointer_stringify(key);
      var valueStr = Pointer_stringify(value);

      console.log('fetch: xhr.setRequestHeader("' + keyStr + '", "' + valueStr + '");');

      xhr.setRequestHeader(keyStr, valueStr);
    }
  }
  Fetch.xhrs.push(xhr);
  var id = Fetch.xhrs.length;
  HEAPU32[fetch + Fetch.fetch_t_offset_id >> 2] = id;
  var data = (dataPtr && dataLength) ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
  // TODO: Support specifying custom headers to the request.

  xhr.onload = function(e) {
    var len = xhr.response ? xhr.response.byteLength : 0;
    var ptr = 0;
    var ptrLen = 0;
    if (fetchAttrLoadToMemory && !fetchAttrStreamData) {
      ptrLen = len;

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    if (len) {
      // If the final XHR.onload handler receives the bytedata to compute total length, report that,
      // otherwise don't write anything out here, which will retain the latest byte size reported in
      // the most recent XHR.onprogress handler.
      Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState === 4 && xhr.status === 0) {
      if (len > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we got data bytes.
      else xhr.status = 404; // Conversely, no data bytes is 404.
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (xhr.status == 200) {

      console.log('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" succeeded with status 200');

      if (onsuccess) onsuccess(fetch, xhr, e);
    } else {

      console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" failed with status ' + xhr.status);

      if (onerror) onerror(fetch, xhr, e);
    }
  }
  xhr.onerror = function(e) {
    var status = xhr.status; // XXX TODO: Overwriting xhr.status doesn't work here, so don't override anywhere else either.
    if (xhr.readyState == 4 && status == 0) status = 404; // If no error recorded, pretend it was 404 Not Found.

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" finished with error, readyState ' + xhr.readyState + ' and status ' + status);

    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, 0);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = status;
    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.ontimeout = function(e) {

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" timed out, readyState ' + xhr.readyState + ' and status ' + xhr.status);

    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.onprogress = function(e) {
    var ptrLen = (fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response) ? xhr.response.byteLength : 0;
    var ptr = 0;
    if (fetchAttrLoadToMemory && fetchAttrStreamData) {

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, e.loaded - ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, e.total);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we get data bytes
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (onprogress) onprogress(fetch, xhr, e);
  }

  console.log('fetch: xhr.send(data=' + data + ')');

  try {
    xhr.send(data);
  } catch(e) {

    console.error('fetch: xhr failed with exception: ' + e);

    if (onerror) onerror(fetch, xhr, e);
  }
}

function emscripten_start_fetch(fetch, successcb, errorcb, progresscb) {
  if (typeof Module !== 'undefined') Module['noExitRuntime'] = true; // If we are the main Emscripten runtime, we should not be closing down.

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  var onsuccess = HEAPU32[fetch_attr + Fetch.attr_t_offset_onsuccess >> 2];
  var onerror = HEAPU32[fetch_attr + Fetch.attr_t_offset_onerror >> 2];
  var onprogress = HEAPU32[fetch_attr + Fetch.attr_t_offset_onprogress >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);

  var reportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. e: ' + e);

    if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
    else if (successcb) successcb(fetch);
  };

  var cacheResultAndReportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. Caching result.. e: ' + e);

    var storeSuccess = function(fetch, xhr, e) {

      console.log('fetch: IndexedDB store succeeded.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    var storeError = function(fetch, xhr, e) {

      console.error('fetch: IndexedDB store failed.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
  };

  var reportProgress = function(fetch, xhr, e) {
    if (onprogress && typeof dynCall === 'function') Module['dynCall_vi'](onprogress, fetch);
    else if (progresscb) progresscb(fetch);
  };

  var reportError = function(fetch, xhr, e) {

    console.error('fetch: operation failed: ' + e);

    if (onerror && typeof dynCall === 'function') Module['dynCall_vi'](onerror, fetch);
    else if (errorcb) errorcb(fetch);
  };

  var performUncachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (uncached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
  };

  var performCachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (cached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
  };

  // Should we try IndexedDB first?
  if (!fetchAttrReplace || requestMethod === 'EM_IDB_STORE' || requestMethod === 'EM_IDB_DELETE') {
    if (!Fetch.dbInstance) {

      console.error('fetch: failed to read IndexedDB! Database is not open.');

      reportError(fetch, 0, 'IndexedDB is not open');
      return 0; // todo: free
    }

    if (requestMethod === 'EM_IDB_STORE') {
      var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
      var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];
      var data = HEAPU8.slice(dataPtr, dataPtr + dataLength); // TODO(?): Here we perform a clone of the data, because storing shared typed arrays to IndexedDB does not seem to be allowed.
      __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, data, reportSuccess, reportError);
    } else if (requestMethod === 'EM_IDB_DELETE') {
      __emscripten_fetch_delete_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrNoDownload) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrPersistFile) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performCachedXhr);
    } else {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performUncachedXhr);
    }
  } else if (!fetchAttrNoDownload) {
    if (fetchAttrPersistFile) {
      __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
    } else {
      __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
    }
  } else {

    console.error('fetch: Invalid combination of flags passed.');

    return 0; // todo: free
  }
  return fetch;
}

if (typeof Atomics === 'undefined') {
  // Polyfill singlethreaded atomics ops from http://lars-t-hansen.github.io/ecmascript_sharedmem/shmem.html#Atomics.add
  // No thread-safety needed since we don't have multithreading support.
  Atomics = {};
  Atomics['add'] = function(t, i, v) { var w = t[i]; t[i] += v; return w; }
  Atomics['and'] = function(t, i, v) { var w = t[i]; t[i] &= v; return w; }
  Atomics['compareExchange'] = function(t, i, e, r) { var w = t[i]; if (w == e) t[i] = r; return w; }
  Atomics['exchange'] = function(t, i, v) { var w = t[i]; t[i] = v; return w; }
  Atomics['wait'] = function(t, i, v, o) { if (t[i] != v) return 'not-equal'; else return 'timed-out'; }
  Atomics['wake'] = function(t, i, c) { return 0; }
  Atomics['wakeOrRequeue'] = function(t, i1, c, i2, v) { return 0; }
  Atomics['isLockFree'] = function(s) { return true; }
  Atomics['load'] = function(t, i) { return t[i]; }
  Atomics['or'] = function(t, i, v) { var w = t[i]; t[i] |= v; return w; }
  Atomics['store'] = function(t, i, v) { t[i] = v; return v; }
  Atomics['sub'] = function(t, i, v) { var w = t[i]; t[i] -= v; return w; }
  Atomics['xor'] = function(t, i, v) { var w = t[i]; t[i] ^= v; return w; }
}

var Atomics_add = Atomics.add;
var Atomics_and = Atomics.and;
var Atomics_compareExchange = Atomics.compareExchange;
var Atomics_exchange = Atomics.exchange;
var Atomics_wait = Atomics.wait;
var Atomics_wake = Atomics.wake;
var Atomics_wakeOrRequeue = Atomics.wakeOrRequeue;
var Atomics_isLockFree = Atomics.isLockFree;
var Atomics_load = Atomics.load;
var Atomics_or = Atomics.or;
var Atomics_store = Atomics.store;
var Atomics_sub = Atomics.sub;
var Atomics_xor = Atomics.xor;

var ENVIRONMENT_IS_FETCH_WORKER = true;
var ENVIRONMENT_IS_WORKER = true;
var ENVIRONMENT_IS_PTHREAD = true;
var __pthread_is_main_runtime_thread=0;
var DYNAMICTOP_PTR = 0;
var TOTAL_MEMORY = 0;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays, since compiling with pthreads support enabled (-s USE_PTHREADS=1).');
}
var nan = NaN;
var inf = Infinity;

function _emscripten_asm_const_v() {}

function assert(condition) {
  if (!condition) console.error('assert failure!');
}

/// TODO: DO SOMETHING ABOUT ME.
function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return "";
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = "";

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}

Fetch.staticInit();

var queuePtr = 0;
var buffer = null;
var STACKTOP = 0;
var STACK_MAX = 0;
var HEAP8 = null;
var HEAPU8 = null;
var HEAP16 = null;
var HEAPU16 = null;
var HEAP32 = null;
var HEAPU32 = null;

function processWorkQueue() {
  if (!queuePtr) return;
  var numQueuedItems = Atomics_load(HEAPU32, queuePtr + 4 >> 2);
  if (numQueuedItems == 0) return;

  var queuedOperations = Atomics_load(HEAPU32, queuePtr >> 2);
  var queueSize = Atomics_load(HEAPU32, queuePtr + 8 >> 2);
  for(var i = 0; i < numQueuedItems; ++i) {
    var fetch = Atomics_load(HEAPU32, (queuedOperations >> 2)+i);
    function successcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function errorcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function progresscb(fetch) {
    }
    try {
      emscripten_start_fetch(fetch, successcb, errorcb, progresscb);
    } catch(e) {
      console.error(e);
    }
    /*
    if (interval != undefined) {
      clearInterval(interval);
      interval = undefined;
    }
    */
  }
  Atomics_store(HEAPU32, queuePtr + 4 >> 2, 0);
}

interval = 0;
this.onmessage = function(e) {
  if (e.data.cmd == 'init') {
    queuePtr = e.data.queuePtr;
    buffer = e.data.buffer;
    STACKTOP = e.data.STACKTOP;
    STACK_MAX = e.data.STACK_MAX;
    DYNAMICTOP_PTR = e.data.DYNAMICTOP_PTR;
    TOTAL_MEMORY = e.data.TOTAL_MEMORY;
    HEAP8 = new Int8Array(buffer);
    HEAPU8 = new Uint8Array(buffer);
    HEAP16 = new Int16Array(buffer);
    HEAPU16 = new Uint16Array(buffer);
    HEAP32 = new Int32Array(buffer);
    HEAPU32 = new Uint32Array(buffer);
    interval = setInterval(processWorkQueue, 100);
  }
}
